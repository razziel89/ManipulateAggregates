"""
Check for orbital character.
"""
import sys

import numpy as np
    
from collection.write import print_dx_file as pdx
from collection.read import read_dx as rdx

from orbitalcharacter.read_MO_basis import get_MOs_and_basis
from orbitalcharacter.Smatrix import Smatrix, normalize_basis, overlap_lincomb, normalize_MO
from orbitalcharacter.density_on_grid import prepare_grid_calculation,density_on_grid

def _expand_total_wavefunction(MOs,Smatrix,normalize=False):
    Bsize  = len(Smatrix)
    MOsize = len(MOs)
    RHS    = [    sum((
                        coeff*Skj
                   for mo in MOs for Skj,coeff in zip(Sk,mo)
                   ))
             for Sk in Smatrix
             ]
    #I want to have: |P> = SUM (d_k*|phi_k>) for i in inteval [0,N]
    #with: P: total wavefunction, d_k: linear combination coefficient
    #      S_ik: element of the overlap matrix i.e. <phi_i|phi_k> (symmetric)
    #      N: nr. basis functions
    #      |phi_k>: k-th basis function
    #Hence, <phi_i|P> = SUM (d_k <phi_i|phi_k>) for k in interval [0,N]
    #                 = SUM (d_k S_ik) for k in interval [0,N]
    #With v = [<phi_1|P>,<phi_2|P>,...,<phi_N|P>] and d = [d_1,d_2,...,d_N] (Python lists as vectors)
    #     follows v = S dot d (dot: matrix product)
    #     and hence the equation S*d=v has to be solved for v
    #solves S*d=RHS where d is the vector containing the coefficients of interest
    result = np.linalg.solve(Smatrix,RHS)
    if normalize:
        result /= sqrt(overlap_lincomb(Smatrix,result))
    return result

def single_data(filename,header=None,dir="",progress=False,save_all_mos=False,points=80):
    """
    Create what data can be created when only the results of one
    calculation are available. If header is None, a suitable header will
    be autogenerated. WARNING: It is implicitly assumed that the calculations
    that will later be compared using postprocess_multiple have exactly
    the same basis.

    filename: str
        The name of the output molden-file.
    header: dict with keys:
        counts_xyz, org_xyz, delta_x, delta_y, delta_z:
            counts_xyz: list of 3 int:
                How many points in each Cartesian direction shall
                the grid have.
            org_xyz: list of 3 floats
                The origin of the grid.
            delta_x: list of 3 float
                The first vector that defines one voxel.
            delta_y: list of 3 float
                The second vector that defines one voxel.
            delta_z: list of 3 float
                The third vector that defines one voxel.
            All values have to be in Angstroms.
    dir: str
        Directory name to be prefixed to all output files.
    """
    if len(dir)>0:
        if not dir.endswith("/"):
            dir+="/"
    #FRACTIONAL OCCUPATIONS ARE NOT SUPPORTED!!!
    #read in the molden file and extract spin-polarized MO information from it
    #also read in basis information
    #only occupied orbitals are being read in (occupation > 0.1)
    print >>sys.stderr,"DEBUG: started check of orbital character"
    basis,MOsalpha,MOsbeta  = get_MOs_and_basis(filename,occ_func=lambda o:o>0.1,filetype="molden",spins='both')
    print >>sys.stderr,"DEBUG: reading molden-files and basis generation done"
    if header is None:
        from collection.read import read_molden
        #read_molden returns coordinates in Bohr but I want Angstroms at this position
        coordinates = np.array([c[1] for c in read_molden(filename,positions=True,GTO=False,MO=False)["positions"]])*0.52918
        min_corner = np.amin(coordinates,axis=0)-10.0
        max_corner = np.amax(coordinates,axis=0)+10.0
        counts_xyz = np.array([points,points,points])
        org_xyz   = min_corner
        #grid creation copied from energyscan.py but slightly altered
        space = [np.linspace(s,e,num=c,dtype=float)
                    for s,e,c
                    in zip(min_corner,max_corner,counts_xyz)
               ]
        #just take the difference between the first elements in every direction to get the stepsize
        delta_x = np.array([space[0][1] - space[0][0], 0.0, 0.0])
        delta_y = np.array([0.0, space[1][1] - space[1][0], 0.0])
        delta_z = np.array([0.0, 0.0, space[2][1] - space[2][0]])
        a1,a2,a3  = np.array(np.meshgrid(*space,indexing="ij"))
        a1.shape  = (-1,1)
        a2.shape  = (-1,1)
        a3.shape  = (-1,1)
        grid      = np.concatenate((a1,a2,a3),axis=1)
        print >>sys.stderr,"DEBUG: generated grid for dx-files"
        print >>sys.stderr,"DEBUG: autogenerated header for dx-files"
    else:
        counts_xyz = header["counts_xyz"]
        org_xyz    = header["org_xyz"]
        delta_x    = header["delta_x"]
        delta_y    = header["delta_y"]
        delta_z    = header["delta_z"]
        print >>sys.stderr,"DEBUG: done reading data from header"
    Smat = Smatrix(basis)
    print >>sys.stderr,"DEBUG: built S matrix"
    Smat = normalize_basis(basis,Smat)
    print >>sys.stderr,"DEBUG: renormalized basis and corrected Smatrix"
    normalize_MO(Smat,MOsalpha)
    normalize_MO(Smat,MOsbeta)
    print >>sys.stderr,"DEBUG: renormalized molecular orbitals"
    #expand all total wave functions in terms of the basis functions
    psialpha = _expand_total_wavefunction(MOsalpha,Smat)
    psibeta  = _expand_total_wavefunction(MOsbeta,Smat)
    print >>sys.stderr,"DEBUG: expansion in terms of basis functions done"
    nr_electrons_alpha = int(round(overlap_lincomb(Smat,psialpha)))
    nr_electrons_beta  = int(round(overlap_lincomb(Smat,psibeta)))
    nr_electrons       = nr_electrons_alpha + nr_electrons_beta
    #the grid has been read in in Angstroms so it has to be converted to bohrs
    data = prepare_grid_calculation(grid,basis,scale=0.52918) 
    print >>sys.stderr,"DEBUG: prepared grid calculation"
    async = progress
    if save_all_mos:
        tot_dens = np.zeros((len(grid),),dtype=float)
        if MOsalpha == MOsbeta:
            mocount=1
            for mo in MOsalpha:
                tempdens = np.array(density_on_grid([mo],data,async=async,normalize_to=1))
                pdx(dir+"MO"+str(mocount)+"alpha.dx",counts_xyz,org_xyz,delta_x,delta_y,delta_z,tempdens,comment="Nr. Electrons: %d"%(1))
                pdx(dir+"MO"+str(mocount)+"beta.dx", counts_xyz,org_xyz,delta_x,delta_y,delta_z,tempdens,comment="Nr. Electrons: %d"%(1))
                tot_dens += 2*tempdens
                mocount += 1
        else:
            mocount=1
            for mo in MOsalpha:
                tempdens = np.array(density_on_grid([mo],data,async=async,normalize_to=1))
                pdx(dir+"MO"+str(mocount)+"alpha.dx",counts_xyz,org_xyz,delta_x,delta_y,delta_z,tempdens,comment="Nr. Electrons: %d"%(1))
                tot_dens += tempdens
                mocount += 1
            mocount=1
            for mo in MOsbeta:
                tempdens = np.array(density_on_grid([mo],data,async=async,normalize_to=1))
                pdx(dir+"MO"+str(mocount)+"beta.dx", counts_xyz,org_xyz,delta_x,delta_y,delta_z,tempdens,comment="Nr. Electrons: %d"%(1))
                tot_dens += tempdens
                mocount += 1
    else:
        if MOsalpha == MOsbeta:
            tot_dens = np.array(density_on_grid(MOsalpha,data,async=async,normalize_to=nr_electrons))
        else:
            tot_dens = np.array(density_on_grid(MOsalpha+MOsbeta,data,async=async,normalize_to=nr_electrons))
    print >>sys.stderr,"DEBUG: generated total density on grid"
    pdx(dir+"rho.dx",counts_xyz,org_xyz,delta_x,delta_y,delta_z,tot_dens,comment="Nr. Electrons: %d"%(nr_electrons))
    print >>sys.stderr,"DEBUG: wrote dx-file for total density"
    dens_homo_alpha = np.array(density_on_grid([MOsalpha[-1]],data,async=async,normalize_to=1))
    dens_homo_beta  = np.array(density_on_grid([MOsalpha[-1]],data,async=async,normalize_to=1))
    print >>sys.stderr,"DEBUG: computed HOMO densities (both spins)"
    pdx(dir+"HOMO1.dx",counts_xyz,org_xyz,delta_x,delta_y,delta_z,dens_homo_alpha,comment="Nr. Electrons: %d"%(nr_electrons_alpha))
    pdx(dir+"HOMO2.dx",counts_xyz,org_xyz,delta_x,delta_y,delta_z,dens_homo_beta,comment="Nr. Electrons: %d"%(nr_electrons_beta))
    print >>sys.stderr,"DEBUG: wrote dx-files for HOMO densities (both spins)"
    print >>sys.stderr,"DEBUG: done check of orbital character"

def _similarity(array1,array2,type=0):
    #The overlap is being computed as 1 minus half of the sum over the absolute differences.
    #This sum would be 2 if both densities were completely different and would be 0 if
    #both densities were completely the same. This relation only holds because both densities
    #are normalized to 1.
    #The type specifies one of two possible similarity measures. More might be added later.
    if type == 0:
        return np.sum(np.fabs(array1-array2))/(np.sum(np.fabs(array1))+np.sum(np.fabs(array2)))
    elif type == 1:
        temparray1 = array1/np.sum(np.fabs(array1))
        temparray2 = array2/np.sum(np.fabs(array2))
        return np.sum(np.fabs(temparray1-temparray2))/2.0
    elif type == 2:
        return np.sum(np.square(array1-array2))
    else:
        raise ValueError("Wrong type of similarity measure given.")

def _compare_densities(file1,file2):
    header={}
    data1  = np.array(rdx(file1,density=True,silent=True,grid=False,header_dict=header)["data"])
    data2  = np.array(rdx(file2,density=True,silent=True,grid=False                   )["data"])
    otypes = 3
    names = ["own1","own2","own3"]
    overlap = tuple(_similarity(data1,data2,t) for t in xrange(otypes))
    for t,a in zip(xrange(otypes),overlap):
        print "Type %15s: Overlap: %8.4e"%(names[t],a)

def postprocess_multiple(total_1,total_2,HOMOalpha_1,HOMObeta_1,HOMOalpha_2,HOMObeta_2,dir=""):
    """
    After creating all dx-files for each sub-calculation, use this function on both dx-files
    to aggregate the data.

    total_1, total_2: str
        Names of the dx-files that contain the total density.
    HOMOalpha_1, HOMObeta_1: str
        Names of the dx-files that contain the HOMO density of
        alpha and beta skin, first molecule.
    HOMOalpha_2, HOMObeta_2: str
        Names of the dx-files that contain the HOMO density of
        alpha and beta skin, second molecule.
    dir: str
        Directory name to be prefixed to all output files.
    """
    print >>sys.stderr,"DEBUG: started check of orbital character"
    if len(dir)>0:
        if not dir.endswith("/"):
            dir+="/"
    #FRACTIONAL OCCUPATIONS ARE NOT SUPPORTED!!!
    #read in all dx files
    #they have been normalized to the number of electrons
    header={}
    data1  = np.array(rdx(total_1,density=True,silent=True,grid=False,header_dict=header)["data"])
    data2  = np.array(rdx(total_2,density=True,silent=True,grid=False                   )["data"])
    print >>sys.stderr,"DEBUG: reading dx-files done"
    nr_electrons_1 = int(round(np.sum(data1)))
    nr_electrons_2 = int(round(np.sum(data2)))
    if nr_electrons_1 == nr_electrons_2+1:
        neut_total  = data1
        kat_total   = data2
        HOMOalpha   = np.array(rdx(HOMOalpha_1,density=True,silent=True,grid=False)["data"])
        HOMObeta    = np.array(rdx(HOMObeta_1, density=True,silent=True,grid=False)["data"])
        nr_electrons_neut = nr_electrons_1
    elif nr_electrons_1 == nr_electrons_2-1:
        neut_total  = data2
        kat_total   = data1
        HOMOalpha   = np.array(rdx(HOMOalpha_2,density=True,siltent=True,grid=False)["data"])
        HOMObeta    = np.array(rdx(HOMObeta_2, density=True,siltent=True,grid=False)["data"])
        nr_electrons_neut = nr_electrons_2
    else:
        raise ValueError("Both dx files contain data about molecules that do not differ in exactly one electron.")
    print >>sys.stderr,"DEBUG: determined kation and neutral molecule"
    #the grid has been read in in Angstroms so it has to be converted to bohrs
    diffdens = neut_total - kat_total 
    print >>sys.stderr,"DEBUG: computed difference density, sum: %8.4f, sum over abs: %8.4f"%(np.sum(diffdens),np.sum(np.fabs(diffdens)))
    pdx(dir+"diff.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],diffdens)
    print >>sys.stderr,"DEBUG: wrote dx-file for difference density"
    #The overlap is being computed as 1 minus half of the sum over the absolute differences.
    #This sum would be 2 if both densities were completely different and would be 0 if
    #both densities were completely the same. This relation only holds because both densities
    #are normalized to 1.
    otypes = 3
    names = ["own1","own2","own3"]
    overlap_alpha = tuple(_similarity(diffdens,HOMOalpha,t) for t in xrange(otypes))
    overlap_beta  = tuple(_similarity(diffdens,HOMObeta,t) for t in xrange(otypes))
    print >>sys.stderr,"DEBUG: computed overlap between difference density and HOMO densities (both spins)"
    for t,a,b in zip(xrange(otypes),overlap_alpha,overlap_beta):
        print "Type %15s: Overlap alpha/beta: %8.4e /%8.4e"%(names[t],a,b)
    print >>sys.stderr,"DEBUG: done check of orbital character"

#all variable names that contain "alpha" or "beta" are spin-polarized values
if __name__ == "__main__":

    #FRACTIONAL OCCUPATIONS ARE NOT SUPPORTED!!!
    #read in the molden files and extract spin-polarized MO information from them
    #also read in basis information
    #only occupied orbitals are being read in (occupation > 0.1)
    print >>sys.stderr,"DEBUG: started check of orbital character"
    m={}
    basis,MOs1alpha,MOs1beta  = get_MOs_and_basis(sys.argv[1],occ_func=lambda o:o>0.1,filetype="molden",spins='both',msave=m)
    basis2,MOs2alpha,MOs2beta = get_MOs_and_basis(sys.argv[2],occ_func=lambda o:o>0.1,filetype="molden",spins='both')
    print >>sys.stderr,"DEBUG: reading molden-files and basis generation done"
    #this compares all elements in basis and basis2 recursively and only returns True
    #if all elements are the same (i.e. have the same value and are of the same shape)
    if not basis == basis2:
        raise ValueError("The bases defined in the two molden files are not the same, cannot compare.")
    del basis2
    print >>sys.stderr,"DEBUG: basis comparison done"
    Smat = Smatrix(basis)
    print >>sys.stderr,"DEBUG: built S matrix"
    Smat = normalize_basis(basis,Smat)
    print >>sys.stderr,"DEBUG: renormalized basis and corrected Smatrix"
    normalize_MO(Smat,MOs1alpha)
    normalize_MO(Smat,MOs1beta)
    normalize_MO(Smat,MOs2alpha)
    normalize_MO(Smat,MOs2beta)
    print >>sys.stderr,"DEBUG: renormalized molecular orbitals"
    #expand all total wave functions in terms of the basis functions
    psi1alpha = _expand_total_wavefunction(MOs1alpha,Smat)
    psi1beta  = _expand_total_wavefunction(MOs1beta,Smat)
    psi2alpha = _expand_total_wavefunction(MOs2alpha,Smat)
    psi2beta  = _expand_total_wavefunction(MOs2beta,Smat)
    print >>sys.stderr,"DEBUG: expansion in terms of basis functions done"
    nr_electrons_1 = int(round(overlap_lincomb(Smat,psi1alpha)))+int(round(overlap_lincomb(Smat,psi1beta)))
    nr_electrons_2 = int(round(overlap_lincomb(Smat,psi2alpha)))+int(round(overlap_lincomb(Smat,psi2beta)))
    if nr_electrons_1 == nr_electrons_2+1:
        neut_alpha  = MOs1alpha
        neut_beta   = MOs1beta
        pos_alpha   = MOs2alpha
        pos_beta    = MOs2beta
        nr_electrons_neut = nr_electrons_1
    elif nr_electrons_1 == nr_electrons_2-1:
        neut_alpha  = MOs2alpha
        neut_beta   = MOs2beta
        pos_alpha   = MOs1alpha
        pos_beta    = MOs1beta
        nr_electrons_neut = nr_electrons_2
    else:
        raise ValueError("Both molden files contain data about molecules that do not differ in exactly one electron.")
    print >>sys.stderr,"DEBUG: determined kation and neutral molecule"
    header={}
    dxfile = rdx(sys.argv[3],density=True,grid=True,header_dict=header)
    grid=dxfile["grid"]
    print >>sys.stderr,"DEBUG: reading example dx-file done"
    #the grid has been read in in Angstroms so it has to be converted to bohrs
    data = prepare_grid_calculation(grid,basis,scale=0.52918) 
    print >>sys.stderr,"DEBUG: prepared grid calculation"
    if neut_alpha == neut_beta:
        tot_dens_neut = np.array(density_on_grid(neut_alpha,data,async=True,normalize_to=nr_electrons_neut))
    else:
        tot_dens_neut = np.array(density_on_grid(neut_alpha+neut_beta,data,async=True,normalize_to=nr_electrons_neut))
    print >>sys.stderr,"DEBUG: generated neutral total density on grid"
    pdx("rho_neut.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],tot_dens_neut)
    print >>sys.stderr,"DEBUG: wrote dx-file for neutral total density"
    tot_dens_kat  = np.array(density_on_grid(pos_alpha+pos_beta,data,async=True,normalize_to=nr_electrons_neut-1))
    print >>sys.stderr,"DEBUG: generated kationic total density on grid"
    pdx("rho_kat.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],tot_dens_kat)
    print >>sys.stderr,"DEBUG: wrote dx-file for kationic total density"
    diffdens = tot_dens_neut - tot_dens_kat
    print >>sys.stderr,"DEBUG: computed difference density, sum: %8.4f, sum over abs: %8.4f"%(np.sum(diffdens),np.sum(np.fabs(diffdens)))
    pdx("diff.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],diffdens)
    print >>sys.stderr,"DEBUG: wrote dx-file for difference density"
    dens_homo_alpha = np.array(density_on_grid([neut_alpha[-1]],data,async=True,normalize_to=1))
    dens_homo_beta  = np.array(density_on_grid([neut_beta[-1]],data,async=True,normalize_to=1))
    print >>sys.stderr,"DEBUG: computed HOMO densities (both spins)"
    pdx("HOMO1.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],dens_homo_alpha)
    pdx("HOMO2.dx",header["counts_xyz"],header["org_xyz"],header["delta_x"],header["delta_y"],header["delta_z"],dens_homo_beta)
    print >>sys.stderr,"DEBUG: wrote dx-files for HOMO densities (both spins)"
    overlap_alpha = _similarity(diffdens,dens_homo_alpha)
    overlap_beta  = _similarity(diffdens,dens_homo_beta)
    print >>sys.stderr,"DEBUG: computed overlap between difference density and HOMO densities (both spins)"
    print "Overlap alpha/beta: %8.4f/%8.4f"%(overlap_alpha,overlap_beta)
    print >>sys.stderr,"DEBUG: done check of orbital character"
