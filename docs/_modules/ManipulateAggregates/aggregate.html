

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ManipulateAggregates.aggregate &mdash; ManipulateAggregates 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> ManipulateAggregates
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ManipulateAggregates</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ManipulateAggregates.aggregate</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ManipulateAggregates.aggregate</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Definitions of the agg class and some auxilliary function.</span>

<span class="sd">If an external module cannot be imported, all the functionality that does not</span>
<span class="sd">require this module is still supported.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This file is part of ManipulateAggregates.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2016 by Torsten Sachse</span>
<span class="c1">#</span>
<span class="c1"># ManipulateAggregates is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># ManipulateAggregates is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with ManipulateAggregates.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">maagbel</span>
<span class="kn">from</span> <span class="nn">maagbel</span> <span class="kn">import</span> <span class="n">pybel</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">hlb</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">visualize</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">orbitalcharacter</span>

<span class="k">global</span> <span class="n">SUPPORTED</span>
<span class="c1"># remember which submodules could successfully be imported and which not</span>
<span class="n">SUPPORTED</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="ManipulateMoleculesError"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.ManipulateMoleculesError">[docs]</a><span class="k">class</span> <span class="nc">ManipulateMoleculesError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="n">E_UNIT_CONVERSION</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;kJ/mol-&gt;meV&quot;</span><span class="p">:</span> <span class="mf">0.09648500</span><span class="p">,</span>
    <span class="s2">&quot;kcal/mol-&gt;meV&quot;</span><span class="p">:</span> <span class="mf">0.02306035</span><span class="p">,</span>
    <span class="s2">&quot;meV-&gt;kJ/mol&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">0.09648500</span><span class="p">,</span>
    <span class="s2">&quot;meV-&gt;kcal/mol&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">0.02306035</span><span class="p">,</span>
    <span class="s2">&quot;kJ/mol-&gt;kcal/mol&quot;</span><span class="p">:</span> <span class="mf">0.09648500</span> <span class="o">/</span> <span class="mf">0.02306035</span><span class="p">,</span>
    <span class="s2">&quot;kcal/mol-&gt;kJ/mol&quot;</span><span class="p">:</span> <span class="mf">0.02306035</span> <span class="o">/</span> <span class="mf">0.09648500</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">## default meshing criteria for the iso surface generation</span>
<span class="k">global</span> <span class="n">MESH_CRITERIA</span>
<span class="n">MESH_CRITERIA</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>


<div class="viewcode-block" id="MissingModuleError"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.MissingModuleError">[docs]</a><span class="k">class</span> <span class="nc">MissingModuleError</span><span class="p">(</span><span class="n">ManipulateMoleculesError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if a required module could not be imported.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="FiletypeException"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.FiletypeException">[docs]</a><span class="k">class</span> <span class="nc">FiletypeException</span><span class="p">(</span><span class="n">ManipulateMoleculesError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if an auto-determined file type is unknown.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="OpenBabelError"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.OpenBabelError">[docs]</a><span class="k">class</span> <span class="nc">OpenBabelError</span><span class="p">(</span><span class="n">ManipulateMoleculesError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if a computation in OpenBabel failed.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span>

    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;numpy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,)</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;numpy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">FireDeamon</span> <span class="k">as</span> <span class="nn">fd</span>

    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,)</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..collection</span> <span class="kn">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">fdread</span>

    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;ManipulateAggregates.collection.read&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,)</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">SUPPORTED</span><span class="p">[</span><span class="s2">&quot;ManipulateAggregates.collection.read&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_assert_supported</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make sure that a module that is required is actually supported on this machine.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: (string) module name</span>

<span class="sd">    Raises:</span>
<span class="sd">        ManipulateAggregates.aggregate.MissingModuleError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">SUPPORTED</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MissingModuleError</span><span class="p">(</span>
                <span class="s2">&quot;Functionality requested that needs </span><span class="si">%s</span><span class="s2"> but there was an error while importing the module:&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">),</span>
                <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Module </span><span class="si">%s</span><span class="s2"> unknown to the import checker.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="k">global</span> <span class="n">FILETYPEDICT</span>
<span class="c1"># copy all formats known to maagbel into a new dictionary</span>
<span class="n">FILETYPEDICT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">pybel</span><span class="o">.</span><span class="n">informats</span><span class="p">:</span>
    <span class="n">FILETYPEDICT</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
<span class="c1"># FILETYPEDICT={entry:entry for entry in pybel.informats}</span>
<span class="c1"># add some custom entries</span>
<span class="n">FILETYPEDICT</span><span class="p">[</span><span class="s2">&quot;mop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mopin&quot;</span>


<span class="k">def</span> <span class="nf">_double_array</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a C array of doubles from a list.&quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">doubleArray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">_vector3</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vector3 has to have exactly 3 elements.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">vector3</span><span class="p">(</span><span class="o">*</span><span class="n">mylist</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_obbitvec</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a maagbel bit vector representation of the mask.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a swig proxy to the maagbel bitvector mask</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Have to start with the zeroth entry.&quot;</span><span class="p">)</span>
    <span class="n">bvmask</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBBitVec</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">bvmask</span><span class="o">.</span><span class="n">SetBitOn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bvmask</span>


<div class="viewcode-block" id="guess_format"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.guess_format">[docs]</a><span class="k">def</span> <span class="nf">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">no_except</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to guess the file format.</span>
<span class="sd">    </span>
<span class="sd">    If the filename contains no dot, try to match the whole filename against</span>
<span class="sd">    OpenBabel&#39;s filetype database. Useful for e.g. CONTCAR files that seldomnly</span>
<span class="sd">    contain a dot.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: (string) the name of the file whose type to guess</span>
<span class="sd">        no_except: (bool) if False, an exception is raised if the filetype is not known.</span>
<span class="sd">            If True, only None will be returned in that case.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the file type or None (depending on no_except)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ManipulateAggregates.aggregate.FiletypeException.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">filetype</span> <span class="o">=</span> <span class="n">FILETYPEDICT</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">extension</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filetype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">no_except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">FiletypeException</span><span class="p">(</span>
            <span class="s2">&quot;Filetype of file &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; not known to maagbel.&quot;</span><span class="p">,</span> <span class="n">e</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">filetype</span></div>


<div class="viewcode-block" id="read_from_file"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.read_from_file">[docs]</a><span class="k">def</span> <span class="nf">read_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">fileformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf_nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="s2">&quot;mmff94&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert content of file to ManipulateAggregates.aggregate.agg.</span>

<span class="sd">    Guesses filetype if none specified. Also converts &quot;~&quot; to the proper home</span>
<span class="sd">    directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: (string) path to the file</span>
<span class="sd">        fileformat: (string or None) guess type if None, otherwise use specified</span>
<span class="sd">            filetype</span>
<span class="sd">        conf_nr: (int or iterable of ints) index/indices of those conformers to be</span>
<span class="sd">            loaded. Special keyword &#39;all&#39; will return all conformers in file.  Special</span>
<span class="sd">            keywords &quot;first&quot; and &quot;last&quot; return the first and last of the conformers,</span>
<span class="sd">            respectively</span>
<span class="sd">        ff: (string) name of the force field to use. Run &quot;manipagg --list forcefields&quot;</span>
<span class="sd">            to get supported ones.</span>

<span class="sd">    Returns:</span>
<span class="sd">        object of ManipulateAggregates.aggregate.agg</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fileformat</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;~.*&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">homedir</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;^~$&quot;</span><span class="p">,</span> <span class="n">homedir</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;^~&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;HOME&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">username</span> <span class="o">=</span> <span class="n">homedir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">homedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;HOME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;^~&quot;</span><span class="p">,</span> <span class="n">homedir</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="n">fileformat</span><span class="p">,</span> <span class="s2">&quot;conf_nr&quot;</span><span class="p">:</span> <span class="n">conf_nr</span><span class="p">,</span> <span class="s2">&quot;ff&quot;</span><span class="p">:</span> <span class="n">ff</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">conf_nr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">conf_nr</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Conformers are counted starting at 1.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">conf_nr</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
        <span class="n">obagg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">pybel</span><span class="o">.</span><span class="n">readfile</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
            <span class="n">obagg</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c1"># obagg = reduce(lambda x,y: y, (m for m in pybel.readfile(fileformat,filename))).OBMol</span>
        <span class="k">return</span> <span class="n">agg</span><span class="p">(</span><span class="n">obagg</span><span class="o">.</span><span class="n">OBMol</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="n">ff</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># conf_nr_iter = itertools.count(start=0,step=1)</span>
        <span class="n">conf_nr_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">conf_nr</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
            <span class="n">conf_nr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">conf_nr_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">max_conf_nr</span> <span class="o">=</span> <span class="n">conf_nr</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conf_nr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">conf_nr_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">==</span> <span class="n">conf_nr</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_conf_nr</span> <span class="o">=</span> <span class="n">conf_nr</span>
        <span class="k">elif</span> <span class="n">conf_nr</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">conf_nr_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">max_conf_nr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Wrong type for argument conf_nr, type is: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">conf_nr</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">gen_conformers</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pmol</span> <span class="ow">in</span> <span class="n">pybel</span><span class="o">.</span><span class="n">readfile</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
                <span class="n">conf_count</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">conf_nr_iter</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">conf_count</span> <span class="o">&gt;=</span> <span class="n">max_conf_nr</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">conf_count</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">OBMol</span><span class="p">)</span>

        <span class="n">conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen_conformers</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">ccount</span><span class="p">,</span> <span class="n">cagg</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">conf_nr_match</span><span class="p">(</span><span class="n">ccount</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                        <span class="n">obagg</span> <span class="o">=</span> <span class="n">cagg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obagg</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">cagg</span><span class="o">.</span><span class="n">GetCoordinates</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">agg</span><span class="p">(</span><span class="n">obagg</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="n">ff</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conf_nr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;You requested conformer number </span><span class="si">%d</span><span class="s2"> but there are fewer in the file.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">conf_nr</span><span class="p">,)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">_RotMatrixAboutAxisByAngle</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Taken from maagbel from file matrix3x3.cpp, method RotAboutAxisByAngle.</span>
<span class="sd">    Generate a rotation matrix about an arbitrary axis by an arbitrary angle.</span>
<span class="sd">    Angle has to be in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">angle</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c</span>

    <span class="n">vtmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vtmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">vtmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Given axis must have shape (3,) but it has shape &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vtmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vtmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
        <span class="n">vtmp</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vtmp</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vtmp</span>

        <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span>

        <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span>

        <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">c</span>

    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">_VectorAngle</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the angle between two vectors in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="n">v2</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dp</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">dp</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>


<div class="viewcode-block" id="dummy_ff"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff">[docs]</a><span class="k">class</span> <span class="nc">dummy_ff</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Dummy class to catch cases when OpenBabel&#39;s force field could not be set up.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="dummy_ff.Setup"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff.Setup">[docs]</a>    <span class="k">def</span> <span class="nf">Setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="dummy_ff.GetUnit"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff.GetUnit">[docs]</a>    <span class="k">def</span> <span class="nf">GetUnit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not to be called, only a dummy.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="dummy_ff.SteepestDescent"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff.SteepestDescent">[docs]</a>    <span class="k">def</span> <span class="nf">SteepestDescent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not to be called, only a dummy.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="dummy_ff.GetCoordinates"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff.GetCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">GetCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not to be called, only a dummy.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="dummy_ff.Energy"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.dummy_ff.Energy">[docs]</a>    <span class="k">def</span> <span class="nf">Energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not to be called, only a dummy.&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="agg"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg">[docs]</a><span class="k">class</span> <span class="nc">agg</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The agg class (agg stands for aggregate)</span>

<span class="sd">    This class is:</span>
<span class="sd">      1. a Python wrapper for the OBAggregate class of the modified OpenBabel</span>
<span class="sd">         version providing pythonic methods that are not very easy to use via</span>
<span class="sd">         OpenBabel&#39;s language bindings</span>
<span class="sd">      2. an extension to the above in the sense that, by interfacing with the other</span>
<span class="sd">         submodules of ManipulateAggregates, additional functionality is provided,</span>
<span class="sd">         such as:</span>

<span class="sd">            - estimation of the HLB value</span>
<span class="sd">            - visualization of an electrostatic potential on a molecular surface</span>

<span class="sd">      3. the base class used for the aggregate geometry estimation implemented in</span>
<span class="sd">         the submodule ManipulateAggregates.energyscan</span>

<span class="sd">    Attributes:</span>
<span class="sd">        obmol: (of type OBAggregate) the underlying OpenBabel data structure</span>
<span class="sd">        info: (dictionary) contains information about the file this object was created</span>
<span class="sd">            from</span>
<span class="sd">        vs: (dictionary) contains information about desired visualizations and surface</span>
<span class="sd">            generation</span>
<span class="sd">        cp: (dictionary) contains information about how to obtain this molecule&#39;s</span>
<span class="sd">            charges and potentials</span>
<span class="sd">        __internal__: (dictionary) internal data, not for direct use</span>
<span class="sd">        ff: (OBForceField) the underlying OpenBabel force field data structure</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default config options for surface generation and visualization.</span>
    <span class="c1">#</span>
    <span class="c1"># See comments for explanations of each parameter.</span>
    <span class="n">default_vs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># The type of plot. &quot;vdw&quot; (van-der-Waals surface) and &quot;iso&quot; (isosurface) will</span>
        <span class="c1"># show the elctrostatic potential on these surfaces. The type &quot;simple&quot; shows</span>
        <span class="c1"># coloured vdW spheres</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;simple&quot;</span><span class="p">,</span>  <span class="c1"># &quot;simple&quot;, &quot;vdw&quot; or &quot;iso&quot;</span>
        <span class="c1"># The isovalue for type &quot;iso&quot;. For electron densities, the default is a good</span>
        <span class="c1"># value.</span>
        <span class="s2">&quot;isovalue&quot;</span><span class="p">:</span> <span class="mf">0.005</span><span class="p">,</span>  <span class="c1"># float</span>
        <span class="c1"># The type of file from which to get the electron density.</span>
        <span class="s2">&quot;isofiletype&quot;</span><span class="p">:</span> <span class="s2">&quot;dx&quot;</span><span class="p">,</span>  <span class="c1"># only &quot;dx&quot; supported</span>
        <span class="c1"># The path to the file from which to get the electron density.</span>
        <span class="s2">&quot;isofile&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># Criteria for generation of the iso surfaces. For further info, see docstring</span>
        <span class="c1"># of funtion IsosurfacePy in external module FireDeamon for further explanations</span>
        <span class="c1"># or the link http://doc.cgal.org/latest/Surface_mesher/index.html. The default</span>
        <span class="c1"># should be fine.</span>
        <span class="s2">&quot;mesh_criteria&quot;</span><span class="p">:</span> <span class="n">MESH_CRITERIA</span><span class="p">,</span>  <span class="c1"># list of 3 floats</span>
        <span class="c1"># Precision value used to compute the isosurface. A lower value results in more</span>
        <span class="c1"># highly discretized surfaces.</span>
        <span class="s2">&quot;rel_precision&quot;</span><span class="p">:</span> <span class="mf">1.0e-06</span><span class="p">,</span>  <span class="c1"># float &gt;0</span>
        <span class="c1"># Which atoms shall be used for the generation of the iso surface. Please see</span>
        <span class="c1"># the keyword &quot;atoms&quot; for the method get_iso_surface for more information.</span>
        <span class="s2">&quot;iso_atoms&quot;</span><span class="p">:</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>  <span class="c1"># int, list of ints or &quot;all&quot; or &quot;noH&quot; or &quot;auto&quot;</span>
        <span class="c1"># The number of refinement steps for the generation of vdW surfaces. A higher</span>
        <span class="c1"># value creates a more highly discretized surface but needs overproportionally</span>
        <span class="c1"># more memory. More than 3 should never be required. See get_vdw_surface.</span>
        <span class="s2">&quot;refine&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># int &gt;0</span>
        <span class="c1"># The shrink factor during surface generation. The default corresponds to vdW</span>
        <span class="c1"># surfaces. See get_vdw_surface for more information.</span>
        <span class="s2">&quot;shrink_factor&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>  <span class="c1"># float &gt;0 and &lt;1</span>
        <span class="c1"># Scale all vdW radii by this value prior to visualization. Used for</span>
        <span class="c1"># visualization types &quot;simple&quot; and &quot;vdw&quot;.</span>
        <span class="s2">&quot;vdw_scale&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># float &gt;0</span>
        <span class="c1"># How the colour scaling shall be obtained. The value &quot;independent&quot; causes</span>
        <span class="c1"># positive and negative colour scales to be independent. The value &quot;dependent&quot;</span>
        <span class="c1"># causes the overall maximum (in terms of the absolute value) to correspond to</span>
        <span class="c1"># the highest potential. If a tuple of 2 strings is given, the first is taken as</span>
        <span class="c1"># a regular expression and the second one as a directory. The color scale will</span>
        <span class="c1"># be chosen in such a way that the color scales defined in all the saved</span>
        <span class="c1"># visualization state files in the given directory (whose names match the</span>
        <span class="c1"># regular expression) are contained within the new color scale.</span>
        <span class="s2">&quot;colorscale&quot;</span><span class="p">:</span> <span class="s2">&quot;independent&quot;</span><span class="p">,</span>  <span class="c1"># &quot;independent&quot;, &quot;dependent&quot; or &quot;REGEX&quot;,&quot;DIR&quot;</span>
        <span class="c1"># Scale the position of all surface vertices by this value.</span>
        <span class="s2">&quot;zoom&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># float &gt;0</span>
        <span class="c1"># The title of the created OpenGL window.</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Molecule Visualization&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># The resolution of the OpenGL window in pixels. Also the base resolution of</span>
        <span class="c1"># images rendered by PoVRay.</span>
        <span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">),</span>  <span class="c1"># tuple of 2 ints &gt;0</span>
        <span class="c1"># If True, red, black and blue correspond to a positive, vanishing and negative</span>
        <span class="c1"># electrostatic potential. If False, another color scheme is used (deep blue,</span>
        <span class="c1"># light blue, green, yellow and red) and deep blue/red correspond to a highly</span>
        <span class="c1"># positive/negative and green to a vanishing potential.</span>
        <span class="s2">&quot;high_contrast&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># A trajectory tells the script how to manipulate the visualization of the given</span>
        <span class="c1"># aggregate.  All images that are rendered can be saved to disk. The format is</span>
        <span class="c1"># comples. Please see the --render-help message of the &quot;manipagg&quot; executable</span>
        <span class="c1"># contained in this bundle.</span>
        <span class="s2">&quot;renderpath&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># Whether or not the OpenGL window shall be shown. Only makes sense with a</span>
        <span class="c1"># renderpath.</span>
        <span class="s2">&quot;hide&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># If &lt;=0, PoVRay support is switched off. If &gt;0, the resolution of the OpenGL</span>
        <span class="c1"># plot will be scaled by this value to get the resolution for the corresponding</span>
        <span class="c1"># PoVRay image.</span>
        <span class="s2">&quot;povray&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># int &gt;0</span>
        <span class="c1"># A file name (no path!!!) to which the visualization state can be saved. No</span>
        <span class="c1"># default.  Information about when and why this state was saved might be</span>
        <span class="c1"># prefixed to the name. Saving the visualization state only works with types</span>
        <span class="c1"># &quot;vdw&quot; and &quot;iso&quot;.</span>
        <span class="s2">&quot;savefile&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># Whether or not to save the visualization state at the beginning of the</span>
        <span class="c1"># visualization.</span>
        <span class="s2">&quot;savestart&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># Whether or not to save the visualization state at the end of the</span>
        <span class="c1"># visualization.</span>
        <span class="s2">&quot;saveend&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># Wether or not to align the aggregate prior to visualization. This is</span>
        <span class="c1"># recommened to make the aggregate better visible. The actual object will not be</span>
        <span class="c1"># changed, only the visualization will be adjusted.</span>
        <span class="s2">&quot;align&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># The non-mass-weighted center of the aggregate will be pot here.</span>
        <span class="s2">&quot;align_center&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># list of 3 floats</span>
        <span class="c1"># The third main axis (usually the longest extend) of the aggregate will point</span>
        <span class="c1"># in this direction.</span>
        <span class="s2">&quot;align_main3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># list of 3 floats</span>
        <span class="c1"># The second main axis of the aggregate will point in this direction.</span>
        <span class="s2">&quot;align_main2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># list of 3 floats</span>
        <span class="c1"># A filename to which a graphical representation of the color scale might be</span>
        <span class="c1"># saved (SVG file)</span>
        <span class="s2">&quot;svgscale&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># A rotation matrix that will be applied to all normal vectors prior to PoVRay</span>
        <span class="c1"># visualization</span>
        <span class="s2">&quot;visrotmat&quot;</span><span class="p">:</span> <span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">45</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="c1"># Default config options for obtaining charges and electrostatic potentials</span>
    <span class="c1">#</span>
    <span class="c1"># See comments for explanations of each parameter.</span>
    <span class="n">default_cp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># How the electrostatic potential shall be obtained. The value &quot;empirical&quot; uses</span>
        <span class="c1"># empirical methods implemented in OpenBabel (generation of partial charges,</span>
        <span class="c1"># which are then used to compute the potential) (fastest method). The value</span>
        <span class="c1"># &quot;orbitals&quot; uses information from quantum mechanical orbitals to compute the</span>
        <span class="c1"># potential (most accurate method). The value &quot;interpolation&quot; interpolates a</span>
        <span class="c1"># given electrostatic potential onto new points in space. The value &quot;charge&quot;</span>
        <span class="c1"># uses externally provided charges instead of, e.g., empirically determined ones</span>
        <span class="c1"># and then computes the potential.</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;empirical&quot;</span><span class="p">,</span>  <span class="c1"># &quot;empirical&quot;, &quot;orbitals&quot;, &quot;interpolation&quot; or &quot;charges&quot;</span>
        <span class="c1"># How empirical charges shall be obtained. Everything supported by OpenBabel is</span>
        <span class="c1"># supported.</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;mmff94&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># Whether or not charges obtained using empirical methods are partial charges or</span>
        <span class="c1"># not.</span>
        <span class="s2">&quot;partial&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># The type of file in which the quantum mechanical orbital data is stored.</span>
        <span class="s2">&quot;orbfiletype&quot;</span><span class="p">:</span> <span class="s2">&quot;molden&quot;</span><span class="p">,</span>  <span class="c1"># only &quot;molden&quot; supported so far</span>
        <span class="c1"># The path to the file in which the quantum mechanical orbital data is stored.</span>
        <span class="s2">&quot;orbfile&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># The type of file in which the charge data is stored.</span>
        <span class="s2">&quot;chargefiletype&quot;</span><span class="p">:</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span>  <span class="c1"># can be &quot;xyz&quot;, &quot;dx&quot; or &quot;cube&quot;</span>
        <span class="c1"># The path to the file in which the charge data is stored.</span>
        <span class="s2">&quot;chargefile&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># The type of file in which the potential data is stored.</span>
        <span class="s2">&quot;potfiletype&quot;</span><span class="p">:</span> <span class="s2">&quot;dx&quot;</span><span class="p">,</span>  <span class="c1"># can be &quot;dx&quot; or &quot;xyz&quot;</span>
        <span class="c1"># The path to the file in which the potential data is stored.</span>
        <span class="s2">&quot;potfile&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># string</span>
        <span class="c1"># Whether or not the computed electrostatic potential should be inverted.</span>
        <span class="s2">&quot;invert_potential&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># bool</span>
        <span class="c1"># How external ptoential data shall be interpolation. You can use &quot;nearest&quot; for</span>
        <span class="c1"># nearest neighbour interpolation or &quot;distance&quot; for inverse distance</span>
        <span class="c1"># interpolation. The latter uses the formula weight=1/(R-Norm())^E. See below.</span>
        <span class="s2">&quot;interpolation&quot;</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>  <span class="c1"># can be &quot;distance&quot; or &quot;nearest&quot;</span>
        <span class="c1"># This is &quot;E&quot; in the above formula. Anything below 3 causes far-away values to</span>
        <span class="c1"># dominate.</span>
        <span class="s2">&quot;int_exponent&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># int &gt;0</span>
        <span class="c1"># This is &quot;R&quot; in the above formula. The value 2 is the Eukledian norm.</span>
        <span class="s2">&quot;int_root&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># int &gt;0</span>
        <span class="c1"># If the distance between a new and an old point is farther than this, consider</span>
        <span class="c1"># its weight to be zero. When computing the density from orbitals, also use this</span>
        <span class="c1"># cutoff for the distance between an atomic center and the point.</span>
        <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span> <span class="mf">7.0</span><span class="p">,</span>  <span class="c1"># float &gt;0</span>
        <span class="c1"># The total charge of this molecule. Only considered for &quot;potfiletype&quot;==&quot;dx&quot;,</span>
        <span class="c1"># &quot;chargefiletype&quot;==&quot;dx&quot; and &quot;chargefiletype&quot;==&quot;cube&quot;.</span>
        <span class="s2">&quot;total_charge&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># float</span>
        <span class="c1"># The property to compute. Used externally only.</span>
        <span class="s2">&quot;property&quot;</span><span class="p">:</span> <span class="s2">&quot;potential&quot;</span><span class="p">,</span>  <span class="c1"># can be &quot;potential&quot; or &quot;density&quot;</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obmol</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="s2">&quot;mmff94&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            obmol: (OBAggregate) the underlying OpenBabel data structure, will be copied</span>
<span class="sd">            ff: (string) declare the forcefield associated with the molecule.  Needed to</span>
<span class="sd">                get the energy and perform a simple forcefield geometry optimization.</span>
<span class="sd">                Run &quot;manipagg --list forcefield&quot; to get supported ones. Can also be None</span>
<span class="sd">                (switched off)</span>
<span class="sd">            info: (dictionary) has keys &#39;name&#39; and &#39;format&#39; detailing the filename and</span>
<span class="sd">                format, respectively. Also, the keys &#39;conf_nr&#39; and &#39;ff&#39; for the used</span>
<span class="sd">                conformer number and force field are required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBAggregate</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;outformat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;nul&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">default_cp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">default_vs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;orb&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;orbcfg&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;pot&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;potcfg&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;cha&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;chacfg&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">ff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">pybel</span><span class="o">.</span><span class="n">forcefields</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Force field not known to maagbel.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ff</span> <span class="o">=</span> <span class="n">dummy_ff</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ff</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBForceField</span><span class="o">.</span><span class="n">FindForceField</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Force field could not be set-up correctly. Much functionality unavailable.&quot;</span><span class="p">,</span>
                        <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ff</span> <span class="o">=</span> <span class="n">dummy_ff</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span> <span class="o">=</span> <span class="n">dummy_ff</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destructor.&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span>

<div class="viewcode-block" id="agg.duplicate"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.duplicate">[docs]</a>    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">read_file</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate myself or re-read the original file.</span>

<span class="sd">        Please be aware that the constructor is called again. The __internal__</span>
<span class="sd">        dictionary is only shallowly copied, all the others are deep copies.</span>

<span class="sd">        Args:</span>
<span class="sd">            read_file: (bool) if True, the original file is read in</span>
<span class="sd">                again instead of duplicating the molecule as it is.</span>

<span class="sd">        Returns:</span>
<span class="sd">            object of ManipulateAggregates.aggregate.agg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">read_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">read_from_file</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                <span class="n">fileformat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">],</span>
                <span class="n">conf_nr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;conf_nr&quot;</span><span class="p">],</span>
                <span class="n">ff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newagg</span> <span class="o">=</span> <span class="n">agg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ff&quot;</span><span class="p">],</span> <span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
            <span class="n">newagg</span><span class="o">.</span><span class="n">cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">)</span>
            <span class="n">newagg</span><span class="o">.</span><span class="n">vs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">)</span>
            <span class="n">newagg</span><span class="o">.</span><span class="n">__internal__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">newagg</span></div>

<div class="viewcode-block" id="agg.get_pointgroup"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_pointgroup">[docs]</a>    <span class="k">def</span> <span class="nf">get_pointgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the point group of the current aggregate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the name of the pointgroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBPointGroup</span><span class="p">()</span>
        <span class="n">sym</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">IdentifyPointGroup</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">sym</span>
        <span class="k">return</span> <span class="n">pg</span></div>

<div class="viewcode-block" id="agg.get_energy"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_energy">[docs]</a>    <span class="k">def</span> <span class="nf">get_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;meV&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the energy associated with the current geometry for the current forcefield.</span>

<span class="sd">        Units can be specified. Supported units are &quot;kJ/mol&quot;, &quot;kcal/mol&quot; and &quot;meV&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            energy in the specified units.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenBabelError</span><span class="p">(</span><span class="s2">&quot;Error setting up forcefield.&quot;</span><span class="p">)</span>
        <span class="n">ffunit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">GetUnit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ffunit</span> <span class="o">!=</span> <span class="n">unit</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conversion</span> <span class="o">=</span> <span class="n">E_UNIT_CONVERSION</span><span class="p">[</span><span class="n">ffunit</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="n">unit</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown target (</span><span class="si">%s</span><span class="s2">) or origin (</span><span class="si">%s</span><span class="s2">) unit. I know: &#39;kJ/mol&#39;, &#39;kcal/mol&#39; and &#39;meV&#39;.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">ffunit</span><span class="p">),</span>
                    <span class="n">e</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conversion</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">Energy</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="n">conversion</span></div>

<div class="viewcode-block" id="agg.optimize"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.optimize">[docs]</a>    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a sinple geometry optimization using the current forcefield.</span>

<span class="sd">        Args:</span>
<span class="sd">            steps: (int) number of optimization steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenBabelError</span><span class="p">(</span><span class="s2">&quot;Error setting up forcefield.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">SteepestDescent</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">GetCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.set_cp"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_cp">[docs]</a>    <span class="k">def</span> <span class="nf">set_cp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an arbitrary configuration option of the dictionary for obtaining charges and potentials.</span>

<span class="sd">        If key and value are lists , key-value pairs will be assigned.</span>
<span class="sd">        If the lists are of unequal lenghts (e.g., n and n+m), only the</span>
<span class="sd">        first n key-value pairs will be treated.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: (string) the property (or properties) to set</span>
<span class="sd">            value: (appropriate) the data associated with the key(s). See</span>
<span class="sd">                ManipulateAggregates.aggregate.agg.default_cp for possible</span>
<span class="sd">                options and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">kviter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kviter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">default_cp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown, skipping.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">default_cp</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown, skipping.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.set_vs"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_vs">[docs]</a>    <span class="k">def</span> <span class="nf">set_vs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an arbitrary configuration option of the dictionary for visualizations and surface generation.</span>

<span class="sd">        If key and value are lists, key-value pairs will be assigned.</span>
<span class="sd">        If the lists are of unequal lenghts (e.g., n and n+m), only the</span>
<span class="sd">        first n key-value pairs will be treated.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: (string or list of strings) the property (or properties) to set</span>
<span class="sd">            value: (appropriate) the data associated with the key(s). See</span>
<span class="sd">                ManipulateAggregates.aggregate.agg.default_vs for possible</span>
<span class="sd">                options and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">kviter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kviter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">default_vs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown, skipping.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">default_vs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown, skipping.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_cp"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_cp">[docs]</a>    <span class="k">def</span> <span class="nf">get_cp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an arbitrary configuration option of the dictionary that configures how charges and potentials are obtained.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: (string) the property whose value you want to get</span>

<span class="sd">        Returns:</span>
<span class="sd">            the value associated with key or None if the key is not present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_vs"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_vs">[docs]</a>    <span class="k">def</span> <span class="nf">get_vs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an arbitrary configuration option of the dictionary for visualizations and surface generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: (string) the property whose value you want to get</span>

<span class="sd">        Returns:</span>
<span class="sd">            the value associated with key or None if the key is not present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.set_bondlength"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_bondlength">[docs]</a>    <span class="k">def</span> <span class="nf">set_bondlength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjust the length of a bond.</span>
<span class="sd">        </span>
<span class="sd">        If the bond connects two parts of a molecule that are otherwise not</span>
<span class="sd">        connected, those parts are moved with the respective atom. Otherwise,</span>
<span class="sd">        move only the 2 given atoms. There does not actually have to be a bond</span>
<span class="sd">        between the given atoms.</span>
<span class="sd">    </span>
<span class="sd">        Example original geometry</span>

<span class="sd">        &gt;&gt;&gt;  _   _</span>
<span class="sd">        &gt;&gt;&gt; |_|-|_|</span>

<span class="sd">        Adjust the middle bond to 3 times it&#39;s original length</span>

<span class="sd">        &gt;&gt;&gt;  _     _</span>
<span class="sd">        &gt;&gt;&gt; |_|---|_|</span>

<span class="sd">        Please note how both squares were moved along with the atoms</span>
<span class="sd">        comprising the bond.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the bond</span>
<span class="sd">            idx2: (int) number of second atom that defines the bond</span>
<span class="sd">            length: (float) the new bond length (in Angstroms)</span>
<span class="sd">            fix: (1 or 2 or None) keep the first or second atom fixed</span>
<span class="sd">                and move only the other. if it is None, move both by half the required</span>
<span class="sd">                distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bond</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBBond</span><span class="p">()</span>
        <span class="n">bond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetBond</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">SetLength</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">SetLength</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">fix</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">SetLength</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The kwarg &#39;fix&#39; has to be in (1,2,None)&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_bondlength"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_bondlength">[docs]</a>    <span class="k">def</span> <span class="nf">get_bondlength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the length of a bond.</span>
<span class="sd">        </span>
<span class="sd">        There does not actually have to be a bond between the given atoms. If</span>
<span class="sd">        projection is not None, the bond will be projected onto the given</span>
<span class="sd">        vector and the length of that projection will be given.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the bond</span>
<span class="sd">            idx2: (int) number of second atom that defines the bond</span>
<span class="sd">            projection: (list of 3 floats) projection vector</span>

<span class="sd">        Returns:</span>
<span class="sd">            (possibly projected) bond length</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idxa</span><span class="p">))</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">))</span>
        <span class="n">pos1</span> <span class="o">=</span> <span class="p">[</span><span class="n">a1</span><span class="o">.</span><span class="n">GetX</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">GetY</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">GetZ</span><span class="p">()]</span>
        <span class="n">pos2</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2</span><span class="o">.</span><span class="n">GetX</span><span class="p">(),</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetY</span><span class="p">(),</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetZ</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetX</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetX</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetY</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetY</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetZ</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetZ</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of projection vector unequal 3.&quot;</span><span class="p">)</span>
            <span class="n">pnorm</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetX</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetX</span><span class="p">())</span> <span class="o">/</span> <span class="n">pnorm</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetY</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetY</span><span class="p">())</span> <span class="o">/</span> <span class="n">pnorm</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">projection</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">GetZ</span><span class="p">()</span> <span class="o">-</span> <span class="n">a2</span><span class="o">.</span><span class="n">GetZ</span><span class="p">())</span> <span class="o">/</span> <span class="n">pnorm</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>

<div class="viewcode-block" id="agg.set_angle"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_angle">[docs]</a>    <span class="k">def</span> <span class="nf">set_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the bond angle in deg.</span>
<span class="sd">        </span>
<span class="sd">        If the angle connects two parts of a molecule that are otherwise not</span>
<span class="sd">        connected, those parts are moved with the respective atom. See</span>
<span class="sd">        ManipulateAggregates.aggregate.agg.set_bondlength for a graphical example.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the angle</span>
<span class="sd">            idx2: (int) number of second atom that defines the angle</span>
<span class="sd">            idx3: (int) number of third atom that defines the angle</span>
<span class="sd">            angle: (float) the new angle (in degrees)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">SetAngle</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx3</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.get_angle"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the bond angle in deg. </span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the angle</span>
<span class="sd">            idx2: (int) number of second atom that defines the angle</span>
<span class="sd">            idx3: (int) number of third atom that defines the angle</span>

<span class="sd">        Returns:</span>
<span class="sd">            the angle defined by the three atoms in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAngle</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx3</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.set_dihedral"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">set_dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">,</span> <span class="n">idx4</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dihedral angle in deg.</span>

<span class="sd">        If the angle connects two parts of a molecule that are otherwise not</span>
<span class="sd">        connected, those parts are moved with the respective atom. See</span>
<span class="sd">        ManipulateAggregates.aggregate.agg.set_bondlength for a graphical example.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the dihedral angle</span>
<span class="sd">            idx2: (int) number of second atom that defines the dihedral angle</span>
<span class="sd">            idx3: (int) number of third atom that defines the dihedral angle</span>
<span class="sd">            idx4: (int) number of fourth atom that defines the dihedral angle</span>
<span class="sd">            angle: (float) the new angle (in degrees)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">SetDihedralAngle</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx3</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx4</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_dihedral"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">get_dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">idx3</span><span class="p">,</span> <span class="n">idx4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the dihedral angle in deg. </span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            idx1: (int) number of first atom that defines the dihedral angle</span>
<span class="sd">            idx2: (int) number of second atom that defines the dihedral angle</span>
<span class="sd">            idx3: (int) number of third atom that defines the dihedral angle</span>
<span class="sd">            idx4: (int) number of fourth atom that defines the dihedral angle</span>

<span class="sd">        Returns:</span>
<span class="sd">            the dihedral angle defined by the four atoms in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetTorsion</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx3</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx4</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.rotate"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate the molecule around an axis by an angle.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            axis: (list of 3 floats) rotate the geometry around this axis</span>
<span class="sd">            angle: (float) the angle for the rotation (in degrees)</span>
<span class="sd">            part: (None or int&gt;=0) if an integer is provided, only treat</span>
<span class="sd">                that part. Please see ManipulateAggregates.aggregate.agg.tag_parts for a</span>
<span class="sd">                definition of &quot;part&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">Rotate</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">RotatePart</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">vec</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">vec</span></div>

<div class="viewcode-block" id="agg.rotate_main"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.rotate_main">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_main</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_index</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate the molecule around one of its main axis by an angle.</span>
<span class="sd">    </span>
<span class="sd">        Args: </span>
<span class="sd">            axis_index: (int, 1, 2 or 3) the index of the main axis to rotate around</span>
<span class="sd">            angle: (float) the angle for the rotation</span>
<span class="sd">            part: (None or int&gt;=0) if an integer is provided, only treat</span>
<span class="sd">                that part. Please see ManipulateAggregates.aggregate.agg.tag_parts for a</span>
<span class="sd">                definition of &quot;part&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">Rotate</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">axis_index</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">RotatePart</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis_index</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.vdw_check"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.vdw_check">[docs]</a>    <span class="k">def</span> <span class="nf">vdw_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check for van-der-Waals clashes.</span>
<span class="sd">        </span>
<span class="sd">        Check whether any two atoms are closer together than the sum of their</span>
<span class="sd">        van-der-Vaals radii.  Perform this check only for atoms that are not</span>
<span class="sd">        connected by an arbitrary number of bonds. Hence, this only makes sense</span>
<span class="sd">        for aggregates.</span>

<span class="sd">        Args:</span>
<span class="sd">            factor: (float) before checking for clashes, each</span>
<span class="sd">                van-der-Waals radius is multiplied by this factor</span>

<span class="sd">        Returns:</span>
<span class="sd">            whether or not any two atoms clash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">IsGoodVDW</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.translate"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate the molecule in a given direction.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            vector: (list of 3 floats) vector that is added to every atom&#39;s coordinate</span>
<span class="sd">            part: (None or int&gt;0=) if an integer is provided, only treat that</span>
<span class="sd">                part. Please see ManipulateAggregates.aggregate.agg.tag_parts</span>
<span class="sd">                for a definition of &quot;part&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">Translate</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">TranslatePart</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">vec</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">vec</span></div>

<div class="viewcode-block" id="agg.move_closer"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.move_closer">[docs]</a>    <span class="k">def</span> <span class="nf">move_closer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">vdw_factor</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">vdw_added</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move two parts of an aggregate closer together.</span>
<span class="sd">        </span>
<span class="sd">        The parts are moved closer together until a clash of vdW surfaces</span>
<span class="sd">        occurs.  Indices start at 1. A &quot;part&quot; is one covalently bound unit as</span>
<span class="sd">        determined by the force field. If tagging was enabled using</span>
<span class="sd">        ManipulateAggregates.aggregate.agg.tag_parts, a &quot;part&quot; is one</span>
<span class="sd">        tagged unit.</span>

<span class="sd">        Args:</span>
<span class="sd">            part1: (int) index indicating the first part in the aggregate that</span>
<span class="sd">                shall be moved closer to another one</span>
<span class="sd">            part2: (int) second index</span>
<span class="sd">            stepsize: (float) stepsize for movement (good value: 0.2)</span>
<span class="sd">            vdw_factor: (float) factor by which all vdW-radii will be</span>
<span class="sd">                multiplied before detecting clashes (default: 0.9)</span>
<span class="sd">            vdw_added: (float) value that is added to all vdW-radii before</span>
<span class="sd">                detecting clashes (default: 0.0)</span>
<span class="sd">            vec: (None or list of 3 floats) if not None, the parts will be</span>
<span class="sd">                moved closer together in the direction of this vector.</span>
<span class="sd">                Otherwise, the parts will be moved closer along the vector</span>
<span class="sd">                connecting their non-mass-weighted centers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">MovePartsCloser</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">part1</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">part2</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">stepsize</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">vdw_factor</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">vdw_added</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vtemp</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">MovePartsCloser</span><span class="p">(</span>
                <span class="n">vtemp</span><span class="p">,</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">part1</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">part2</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">stepsize</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">vdw_factor</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">vdw_added</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">del</span> <span class="n">vtemp</span></div>

<div class="viewcode-block" id="agg.tag_parts"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.tag_parts">[docs]</a>    <span class="k">def</span> <span class="nf">tag_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Manage the use of tagging (and thus change the definition of &quot;part&quot;).</span>

<span class="sd">        Enable, disable or manage tagging. Part indices start at 0. A &quot;part&quot; is</span>
<span class="sd">        one covalently bound unit as determined by the force field. If tagging</span>
<span class="sd">        was enabled, a &quot;part&quot; is one tagged unit.</span>

<span class="sd">        If parts is a list of integers, the molecules that are indexed with</span>
<span class="sd">        the numbers in this list are together added to one tag and tagging is</span>
<span class="sd">        enabled for the entire aggregate. If parts is &lt;0, tagging is disabled.</span>
<span class="sd">        If parts is &gt;0, tagging is enabled (and nothing else happens). If parts</span>
<span class="sd">        is 0, only tagging information is printed.</span>

<span class="sd">        Args:</span>
<span class="sd">            parts: (int or list of ints) see detailed description</span>
<span class="sd">            verbose: (bool) whether or not information about what was changed</span>
<span class="sd">                shall be printed</span>

<span class="sd">        Returns:</span>
<span class="sd">            the index that, from now on, can be used to treat the here tagged</span>
<span class="sd">            unit, or None if no tagging was changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">piter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">EnableTags</span><span class="p">()</span>
            <span class="n">newtag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">CreateTag</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">piter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">AddToTag</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">newtag</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated tagging information:&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">PrintTags</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">parts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">DisableTags</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disabled tagging.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">EnableTags</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enabled tagging.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">PrintTags</span><span class="p">()</span></div>

<div class="viewcode-block" id="agg.append"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append a molecule to the current one.</span>

<span class="sd">        &quot;Appending&quot; means that all the atoms and bonds contained within agg</span>
<span class="sd">        are added (deep-dopied, i.e., you can detele agg afterwards) to the</span>
<span class="sd">        current molecule. No new bonds are formed. Before appending, translate</span>
<span class="sd">        and rotate agg.</span>

<span class="sd">        Args:</span>
<span class="sd">            agg: aggregate to be appended (of the same type)</span>
<span class="sd">            vector: (list of 3 floats) translate agg by this vector prior to appending</span>
<span class="sd">            axis: (list of 3 floats) rotate agg around this axis prior to appending it</span>
<span class="sd">            angle: (float) the angle for the rotation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">AppendMolecule</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">obmol</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">vec</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="agg.glue"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.glue">[docs]</a>    <span class="k">def</span> <span class="nf">glue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Glue a molecule to the current one.</span>
<span class="sd">        </span>
<span class="sd">        Two bonds, one in each involved molecule, will be cut in half and then</span>
<span class="sd">        glued together in such a way, that all atoms connected to i2 and</span>
<span class="sd">        m2 (including those two) but not connected to i1 and m1 will</span>
<span class="sd">        be cleaved and the molecules will be glued together so that i1 and</span>
<span class="sd">        m1 form a proper bond.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            agg: aggregate to be glued to this one (of same type)</span>
<span class="sd">            i1: (int) index specifying the atom of the primary molecule that</span>
<span class="sd">                will be retained</span>
<span class="sd">            i2: (int) index specifying the atom of the primary molecule that</span>
<span class="sd">                will not be retained</span>
<span class="sd">            m1: (int) index specifying the atom of the secondary molecule that</span>
<span class="sd">                will be retained</span>
<span class="sd">            m2: (int) index specifying the atom of the secondary molecule that</span>
<span class="sd">                will not be retained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">BondMolecule</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">obmol</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.cleave"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.cleave">[docs]</a>    <span class="k">def</span> <span class="nf">cleave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cleave a part of a molecule.</span>

<span class="sd">        Cleave all atoms and bonds that are connected to the atom indexed by</span>
<span class="sd">        i2 but not to i1. Leave the rest as it is.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            i1: (int) index specifying the atom of the molecule that</span>
<span class="sd">                will be retained</span>
<span class="sd">            i2: (int) index specifying the atom of the molecule that</span>
<span class="sd">                will not be retained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">CleaveOff</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span></div>

<div class="viewcode-block" id="agg.write"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">fileformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the data of the molecule to disk. </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename: (string) path to the file (INCLUDING the extension)</span>
<span class="sd">            fileformat: (string) output file format (anything that maagbel can write)</span>
<span class="sd">            overwrite: shall the output file be overwritten or not</span>

<span class="sd">        Raises:</span>
<span class="sd">            ManipulateAggregates.aggregate.MissingModuleError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileformat</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileformat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;outformat&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FiletypeException</span><span class="p">(</span>
                <span class="s2">&quot;Filetype of </span><span class="si">%s</span><span class="s2"> could not be automatically determined and this aggregate was not created from a file.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">pybel</span><span class="o">.</span><span class="n">Molecule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.align"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.align">[docs]</a>    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">main3</span><span class="p">,</span> <span class="n">main2</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align an aggregate in space.</span>

<span class="sd">        Align the last two main axes of an aggregate to the two given axes and</span>
<span class="sd">        move the center to the given coordinate.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            point: (list of 3 floats) the new center of the molecule (not mass weighed)</span>
<span class="sd">            main3: (list of 3 floats) the new 3rd main axis (usually the longest extent)</span>
<span class="sd">            main2: (list of 3 floats) the new 2nd main axis</span>
<span class="sd">            part: (None or int&gt;=0) if an integer is provided, only treat that</span>
<span class="sd">                part. Please see ManipulateAggregates.aggregate.agg.tag_parts</span>
<span class="sd">                for a definition of &quot;part&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="p">[[</span><span class="n">point</span><span class="p">,</span> <span class="s2">&quot;point&quot;</span><span class="p">],</span> <span class="p">[</span><span class="n">main3</span><span class="p">,</span> <span class="s2">&quot;third axis&quot;</span><span class="p">],</span> <span class="p">[</span><span class="n">main2</span><span class="p">,</span> <span class="s2">&quot;second axis&quot;</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;Variable &quot;</span>
                    <span class="o">+</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot; not of the correct length, needs 3 elements not &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">main3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">main2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">poi</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="n">ma3</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">main3</span><span class="p">)</span>
            <span class="n">ma2</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">main2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">Align</span><span class="p">(</span><span class="n">poi</span><span class="p">,</span> <span class="n">ma3</span><span class="p">,</span> <span class="n">ma2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">AlignPart</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">poi</span><span class="p">,</span> <span class="n">ma3</span><span class="p">,</span> <span class="n">ma2</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">poi</span><span class="p">,</span> <span class="n">ma3</span><span class="p">,</span> <span class="n">ma2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Main axis vectors have to have a non-vanishing norm.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.mirror"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">center_it</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mirror or point-invert an aggregate.</span>

<span class="sd">        Mirror the molecule either by point inversion or by mirroring at a</span>
<span class="sd">        plane.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            normal: (list of 3 floats) the normal vector of the mirror plane.</span>
<span class="sd">                If its norm is 0, point inversion will be performed.</span>
<span class="sd">            point: (list of 3 floats) either the inversion point or a point in</span>
<span class="sd">                the plane (Hessian normal form)</span>
<span class="sd">            center_it: (bool) whether or not the entire aggregate&#39;s center</span>
<span class="sd">                shall be moved to the origin prior to the operation. The center</span>
<span class="sd">                will automatically be moved back to its original position</span>
<span class="sd">                afterward the procedure.</span>
<span class="sd">            part: (None or int&gt;=0) if an integer is provided, only treat that</span>
<span class="sd">                part. Please see ManipulateAggregates.aggregate.agg.tag_parts</span>
<span class="sd">                for a definition of &quot;part&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nor</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">poi</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">Mirror</span><span class="p">(</span><span class="n">nor</span><span class="p">,</span> <span class="n">poi</span><span class="p">,</span> <span class="n">center_it</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">MirrorPart</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">nor</span><span class="p">,</span> <span class="n">poi</span><span class="p">,</span> <span class="n">center_it</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">nor</span><span class="p">,</span> <span class="n">poi</span></div>

<div class="viewcode-block" id="agg.part"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.part">[docs]</a>    <span class="k">def</span> <span class="nf">part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an OBMol containing all those atoms that are one one side of a plane.</span>

<span class="sd">        The plane is given in the Hessian normal form.</span>

<span class="sd">        Args:</span>
<span class="sd">            normal_vector: (list of 3 floats) the normal vector of the plane</span>
<span class="sd">            coordinate: (list of 3 floats) a point in the plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tempmol</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBMol</span><span class="p">()</span>
        <span class="n">nor</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">coo</span> <span class="o">=</span> <span class="n">_double_array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">PartMolecule</span><span class="p">(</span><span class="n">tempmol</span><span class="p">,</span> <span class="n">nor</span><span class="p">,</span> <span class="n">coo</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">nor</span><span class="p">,</span> <span class="n">coo</span>
        <span class="k">return</span> <span class="n">tempmol</span></div>

<div class="viewcode-block" id="agg.part_aggregate"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.part_aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">part_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an object of the same type containing all those atoms that are one one side of a plane.</span>

<span class="sd">        The plane is given in the Hessian normal form. Please note that the</span>
<span class="sd">        contructor will be called.</span>

<span class="sd">        Args:</span>
<span class="sd">            normal_vector: (list of 3 floats) the normal vector of the plane</span>
<span class="sd">            coordinate: (list of 3 floats) a point in the plane</span>
<span class="sd">            side: (string) If &#39;left&#39;, select those atoms on the side where the</span>
<span class="sd">                normal vector points. If anything else, select all those on the</span>
<span class="sd">                opposite side.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
            <span class="n">normal_vector</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">normal_vector</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Side must be either left or right&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">part</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">),</span> <span class="n">ff</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_partial_charges"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_partial_charges">[docs]</a>    <span class="k">def</span> <span class="nf">get_partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of all partial charges of the atoms according to the specified method.</span>
<span class="sd">        </span>
<span class="sd">        The returned list has the same order as the atoms in the molecule.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of floats containing the partial charges.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError, ManipulateAggregates.aggregate.OpenBabelError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;corecharge&quot;</span><span class="p">:</span>
            <span class="n">partialcharges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_charges</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_charges</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBChargeModel</span><span class="o">.</span><span class="n">FindType</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tmp_charges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tmp_charges</span><span class="o">.</span><span class="n">ComputeCharges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="p">):</span>
                    <span class="n">partialcharges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tmp_charges</span><span class="o">.</span><span class="n">GetPartialCharges</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">OpenBabelError</span><span class="p">(</span><span class="s2">&quot;Error while partitioning partial charges.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Method &#39;&quot;</span>
                    <span class="o">+</span> <span class="n">method</span>
                    <span class="o">+</span> <span class="s2">&quot;&#39; is not a known method for partitioning partial charges. See &#39;manipagg --list charges&#39; for partitioning methods or use &#39;corecharge&#39; to use the core charge.&quot;</span>
                <span class="p">)</span>
            <span class="k">del</span> <span class="n">tmp_charges</span>
        <span class="c1"># qeq does deliver charges of the opposite sign as the rest</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;qeq&quot;</span><span class="p">:</span>
            <span class="n">partialcharges</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">partialcharges</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">partialcharges</span></div>

<div class="viewcode-block" id="agg.set_ecp"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.set_ecp">[docs]</a>    <span class="k">def</span> <span class="nf">set_ecp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ecp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an atom&#39;s (or of multiple ones) core charge property.</span>

<span class="sd">        If idx and ecp are iterables, idx-ecp pairs will be assigned.</span>
<span class="sd">        If the iterables are of unequal lenghts (e.g., n and n+m), only the</span>
<span class="sd">        first n key-value pairs will be treated.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: (int or iterable of ints) the id(s) (starting at 1) of the</span>
<span class="sd">                atom whose ecp shall be set</span>
<span class="sd">            ecp: (int or iterable of ints) the cored charge(s) of the atom</span>
<span class="sd">                whose ecp shall be set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ieiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ecp</span><span class="p">))</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ieiter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">pd</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBPairData</span><span class="p">()</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;ecp&quot;</span><span class="p">)</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">CloneData</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ecp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
                <span class="n">pd</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">OBPairData</span><span class="p">()</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;ecp&quot;</span><span class="p">)</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ecp</span><span class="p">))</span>
                <span class="n">a</span><span class="o">.</span><span class="n">CloneData</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_charges"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_charges">[docs]</a>    <span class="k">def</span> <span class="nf">get_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all charges of the atoms according to ther element numbers.</span>

<span class="sd">        This function respects the atom property &quot;ecp&quot; that might be stored in</span>
<span class="sd">        each of the OBAtom objects, if ecp is True.</span>

<span class="sd">        Args:</span>
<span class="sd">            ecp: (bool) whether or not to respect the core charge property</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            a list of floats containing the elemental charges (possibly minus core charges).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">charges</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ecp</span><span class="p">:</span>
                <span class="n">aecp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">GetData</span><span class="p">(</span><span class="s2">&quot;ecp&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">aecp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">charges</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="n">aecp</span><span class="o">.</span><span class="n">GetValue</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">charges</span></div>

<div class="viewcode-block" id="agg.get_dipole_moment"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_dipole_moment">[docs]</a>    <span class="k">def</span> <span class="nf">get_dipole_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an aggregate&#39;s electric dipole moment from point charges.</span>

<span class="sd">        The currently set method for obtaining partial charges will be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of 3 floats, the electric dipole vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_partial_charges</span><span class="p">()</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
        <span class="n">px</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">py</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pz</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span><span class="p">):</span>
            <span class="n">px</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">c</span>
            <span class="n">py</span> <span class="o">+=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">c</span>
            <span class="n">pz</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">del</span> <span class="n">charges</span><span class="p">,</span> <span class="n">coordinates</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span><span class="p">]</span></div>

<div class="viewcode-block" id="agg.get_coordinates"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the coordinates of all atoms.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of lists of 3 floats, the Cartesian coordinates of the atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">GetX</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">GetY</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">GetZ</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">coordinates</span></div>

<div class="viewcode-block" id="agg.get_center"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_center">[docs]</a>    <span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the non-mass-weighted center of the molecule</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of 3 floats, the Cartesian coordinates of the center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Counting atoms starts at 1, even for masks.&quot;</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_obatom_vec"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_obatom_vec">[docs]</a>    <span class="k">def</span> <span class="nf">get_obatom_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a vector of OBAtom pointers</span>

<span class="sd">        Returns:</span>
<span class="sd">            a swig proxy to the vector of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">atomlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Counting atoms starts at 1, even for masks.&quot;</span><span class="p">)</span>
            <span class="n">atomlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">atomlist</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">]</span>
        <span class="n">obatoms</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">vectorOBAtom</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obatoms</span></div>

<div class="viewcode-block" id="agg.get_main_axes"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_main_axes">[docs]</a>    <span class="k">def</span> <span class="nf">get_main_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the last 2 main axes of the aggregate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tuple of 2 lists of 3 floats, the third and second main axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="c1"># center = numpy.array(self.get_center(mask))</span>
        <span class="c1"># coords = numpy.array(self.get_coordinates())-center</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Counting atoms starts at 1, even for masks.&quot;</span><span class="p">)</span>
            <span class="n">bvmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bit_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1">##mat is the tensor of inertia</span>
        <span class="c1"># mat    = numpy.sum(numpy.array([ [[y*y+z*z,-x*y,-x*z],[-x*y,x*x+z*z,-y*z],[-x*z,-y*z,x*x+y*y]] for x,y,z in coords]),axis=0)</span>
        <span class="c1"># eigvals,eigvecs = numpy.linalg.eig(mat)</span>
        <span class="c1">##the eigenvectors are stored in the coloumns of eigvecs</span>
        <span class="c1">##so it is transposed to have easy access to them</span>
        <span class="c1"># eigvecs = -eigvecs.T</span>
        <span class="c1"># t_main3,t_main2,t_main1 = sorted(zip(eigvals,eigvecs),key=lambda e: e[0])</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">m3</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetMainAxes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m3</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">bvmask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetMainAxes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m3</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="n">main3</span> <span class="o">=</span> <span class="p">(</span><span class="n">m3</span><span class="o">.</span><span class="n">GetX</span><span class="p">(),</span> <span class="n">m3</span><span class="o">.</span><span class="n">GetY</span><span class="p">(),</span> <span class="n">m3</span><span class="o">.</span><span class="n">GetZ</span><span class="p">())</span>
        <span class="n">main2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m2</span><span class="o">.</span><span class="n">GetX</span><span class="p">(),</span> <span class="n">m2</span><span class="o">.</span><span class="n">GetY</span><span class="p">(),</span> <span class="n">m2</span><span class="o">.</span><span class="n">GetZ</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">main3</span><span class="p">,</span> <span class="n">main2</span></div>

<div class="viewcode-block" id="agg.get_align_matrix"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_align_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_align_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main3</span><span class="p">,</span> <span class="n">main2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a matrix to align the aggregate.</span>

<span class="sd">        Return the composite rotation matrix that would align the third and</span>
<span class="sd">        second main axes to the given axes.</span>

<span class="sd">        Args:</span>
<span class="sd">            main3: (list of 3 floats) the new 3rd main axis (usually the longest extent)</span>
<span class="sd">            main2: (list of 3 floats) the new 2nd main axis</span>

<span class="sd">        Returns:</span>
<span class="sd">            a numpy array of shape (3,3) and dtype float, the rotation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="c1"># c_ stands for current</span>
        <span class="n">c_main3</span><span class="p">,</span> <span class="n">c_main2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_main_axes</span><span class="p">()</span>

        <span class="n">tempvec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">main3</span><span class="p">,</span> <span class="n">c_main3</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">_VectorAngle</span><span class="p">(</span><span class="n">main3</span><span class="p">,</span> <span class="n">c_main3</span><span class="p">)</span>
        <span class="n">mat1</span> <span class="o">=</span> <span class="n">_RotMatrixAboutAxisByAngle</span><span class="p">(</span><span class="n">tempvec</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

        <span class="n">c_main2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">c_main2</span><span class="p">)</span>
        <span class="n">tempvec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">main2</span><span class="p">,</span> <span class="n">c_main2</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">_VectorAngle</span><span class="p">(</span><span class="n">main2</span><span class="p">,</span> <span class="n">c_main2</span><span class="p">)</span>
        <span class="n">mat2</span> <span class="o">=</span> <span class="n">_RotMatrixAboutAxisByAngle</span><span class="p">(</span><span class="n">tempvec</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat2</span><span class="p">,</span> <span class="n">mat1</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_povlight_matrix"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_povlight_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_povlight_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a matrix using which to rotate all normal vectors prior to povray visualization.</span>

<span class="sd">        Return the composite rotation matrix that allow a rotation around an</span>
<span class="sd">        axis by an angle. This depends on the currect configuration option for</span>
<span class="sd">        the key &quot;visrotmat&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a numpy array of shape (3,3) and dtype float, the rotation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;visrotmat&quot;</span><span class="p">,</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">_RotMatrixAboutAxisByAngle</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">angle</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span></div>

<div class="viewcode-block" id="agg.get_vdw_radii"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_vdw_radii">[docs]</a>    <span class="k">def</span> <span class="nf">get_vdw_radii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all van-der-Waals radii for the atoms in this aggregate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of floats, van-der-Waals radii of the atoms according to the</span>
<span class="sd">            element table of OpenBabel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">vdw_radii</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">vdw_radii</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">etab</span><span class="o">.</span><span class="n">GetVdwRad</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">vdw_radii</span></div>

<div class="viewcode-block" id="agg.get_names"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of all element symbols of the atoms.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of strings, the element symbols of the atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">names</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">etab</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">names</span></div>

<div class="viewcode-block" id="agg.get_colours"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_colours">[docs]</a>    <span class="k">def</span> <span class="nf">get_colours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of colors associated with the element symbols of the atoms.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of tuples of 3 floats, RGB values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">colours</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">colours</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">etab</span><span class="o">.</span><span class="n">GetRGB</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">colours</span></div>

<div class="viewcode-block" id="agg.get_masses"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_masses">[docs]</a>    <span class="k">def</span> <span class="nf">get_masses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of masses associated with the element symbols of the atoms.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of floats, the masses in atomic units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a=maagbel.OBAtom()</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">masses</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maagbel</span><span class="o">.</span><span class="n">etab</span><span class="o">.</span><span class="n">GetMass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">masses</span></div>

<div class="viewcode-block" id="agg.get_vdw_surface"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_vdw_surface">[docs]</a>    <span class="k">def</span> <span class="nf">get_vdw_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr_refinements</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shrink_factor</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">vdwscale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the aggregate&#39;s discretized van-der-Waals surface.</span>

<span class="sd">        Do not call directly. Rather use ManipulateAggregates.aggregate.agg.get_surface</span>
<span class="sd">        and set properties via ManipulateAggregates.aggregate.agg.set_vs beforehand.</span>

<span class="sd">        Uses CGAL&#39;s skin surface mesher. Please see</span>
<span class="sd">        http://doc.cgal.org/latest/Skin_surface_3/index.html for more</span>
<span class="sd">        information on this.</span>

<span class="sd">        Args:</span>
<span class="sd">            nr_refinements: (int) number of refinement steps for the skin</span>
<span class="sd">                surface generation. The higher the number the more vertices it</span>
<span class="sd">                will have.</span>
<span class="sd">            shrink_factor: the shrink factor for the generation of the skin</span>
<span class="sd">                surface. Must be between 0 and 1 (not including those). The</span>
<span class="sd">                bigger the value the tighter the surface will be.</span>
<span class="sd">            vdwscale: (float) multiply each vdW radius by this value before</span>
<span class="sd">                building the surface</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tuple of corners,face_indices,normals. corners (a list of lists</span>
<span class="sd">            of 3 floats) contains the Cartesian coordinates of all vertices of</span>
<span class="sd">            the surface. face_indices (list of lists of 3 ints) each triple of</span>
<span class="sd">            integers defines one face of the surface. The indices correspond to</span>
<span class="sd">            corners. normals (list of lists of 3 floats) each triple defines</span>
<span class="sd">            the normal vector associated with the corresponding face.</span>


<span class="sd">        Example in 2D for nr_points=12</span>

<span class="sd">        . : point on the sphere&#39;s surface</span>
<span class="sd">        </span>
<span class="sd">        X : center of the sphere</span>

<span class="sd">        Not overlapping =&gt; 12 points per sphere</span>

<span class="sd">        &gt;&gt;&gt;    ...   ...</span>
<span class="sd">        &gt;&gt;&gt;   .   . .   .</span>
<span class="sd">        &gt;&gt;&gt;   . X . . X .</span>
<span class="sd">        &gt;&gt;&gt;   .   . .   .</span>
<span class="sd">        &gt;&gt;&gt;    ...   ...</span>

<span class="sd">        Overlapping =&gt; points that would be within the other sphere are removed =&gt; 9</span>
<span class="sd">        points per &quot;sphere&quot;</span>

<span class="sd">        &gt;&gt;&gt;    ......</span>
<span class="sd">        &gt;&gt;&gt;   .      .</span>
<span class="sd">        &gt;&gt;&gt;   . X  X .</span>
<span class="sd">        &gt;&gt;&gt;   .      .</span>
<span class="sd">        &gt;&gt;&gt;    ......</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">)</span>

        <span class="n">vdw_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">vdwscale</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vdw_radii</span><span class="p">()]</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>

        <span class="n">lengths</span><span class="p">,</span> <span class="n">face_indices</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">SkinSurfacePy</span><span class="p">(</span>
            <span class="n">shrink_factor</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">vdw_radii</span><span class="p">,</span> <span class="n">refinesteps</span><span class="o">=</span><span class="n">nr_refinements</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">corners</span><span class="p">,</span> <span class="n">face_indices</span><span class="p">,</span> <span class="n">normals</span></div>

<div class="viewcode-block" id="agg.get_iso_surface"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_iso_surface">[docs]</a>    <span class="k">def</span> <span class="nf">get_iso_surface</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">isovalue</span><span class="p">,</span>
        <span class="n">isofile</span><span class="p">,</span>
        <span class="n">isofiletype</span><span class="o">=</span><span class="s2">&quot;dx&quot;</span><span class="p">,</span>
        <span class="n">mesh_criteria</span><span class="o">=</span><span class="n">MESH_CRITERIA</span><span class="p">,</span>
        <span class="n">relative_precision</span><span class="o">=</span><span class="mf">1.0e-06</span><span class="p">,</span>
        <span class="n">atoms</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a discretized iso surface of the aggregate.</span>

<span class="sd">        Do not call directly. Rather use ManipulateAggregates.aggregate.agg.get_surface</span>
<span class="sd">        and set properties via ManipulateAggregates.aggregate.agg.set_vs beforehand.</span>
<span class="sd">        Please see http://doc.cgal.org/latest/Surface_mesher/index.html for</span>
<span class="sd">        more information.</span>

<span class="sd">        Args:</span>
<span class="sd">            isovalue: (float) the isovalue for the surface</span>
<span class="sd">            isofile: (string) path to the file from which to take the volumetric data</span>

<span class="sd">        Args:</span>
<span class="sd">            isofiletype: (string) filetype of the volumetric data file. Only &quot;dx&quot; is</span>
<span class="sd">                supported as of now. &quot;cube&quot; might be added later.</span>
<span class="sd">            mesh_criteria: (list of 3 floats) CGAL&#39;s internal meshing criteria</span>
<span class="sd">            relative_precision: (float) CGAL&#39;s internal precision for meshing</span>
<span class="sd">            atoms: (int, list of ints or &quot;all&quot; or &quot;noH&quot; or &quot;auto&quot;) CGAL&#39;s mesh</span>
<span class="sd">                generation requires a point inside the isosurface. For a</span>
<span class="sd">                chemical compound, all atoms should lie within the isosurface.</span>
<span class="sd">                For aggregates, this is not the case. Here, specofy at least</span>
<span class="sd">                one atom of every covalently bound unit. The special values</span>
<span class="sd">                &quot;all&quot; and &quot;noH&quot; select all atoms or only non-hydrogen atoms.</span>
<span class="sd">                The special value &quot;auto&quot; automatically uses the first atom of</span>
<span class="sd">                each covalently bound unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tuple of corners,face_indices,normals. corners (a list of lists</span>
<span class="sd">            of 3 floats) contains the Cartesian coordinates of all vertices of</span>
<span class="sd">            the surface. face_indices (list of lists of 3 ints) each triple of</span>
<span class="sd">            integers defines one face of the surface. The indices correspond to</span>
<span class="sd">            corners. normals (list of lists of 3 floats) each triple defines</span>
<span class="sd">            the normal vector associated with the corresponding face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">)</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;ManipulateAggregates.collection.read&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="c1"># GetConnections gives back a string that contains</span>
            <span class="c1"># all the atom indices in one covalently bound unit</span>
            <span class="c1"># per line. The first entry, however, is the molecule</span>
            <span class="c1"># index.</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetConnections</span><span class="p">()</span>
            <span class="c1"># split by line -&gt; convert each entry to int (apart form first)</span>
            <span class="c1">#               -&gt; sort by number -&gt; take first entry of sorted list</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: Using only one atom to generate iso surface.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
            <span class="p">)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()[</span><span class="n">atoms</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">atoms</span> <span class="o">==</span> <span class="s2">&quot;noH&quot;</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_names</span><span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">atoms</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">isofiletype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;dx&quot;</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_dx</span><span class="p">(</span>
                <span class="n">isofile</span><span class="p">,</span>
                <span class="n">unit_conversion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">invert_charge_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">header_dict</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">gzipped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">comments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;org_xyz&quot;</span><span class="p">]</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;counts_xyz&quot;</span><span class="p">]</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;delta_x&quot;</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;delta_y&quot;</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;delta_z&quot;</span><span class="p">]]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>

            <span class="n">lengths</span><span class="p">,</span> <span class="n">face_indices</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">IsosurfacePy</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">origin</span><span class="p">,</span>
                <span class="n">counts</span><span class="p">,</span>
                <span class="n">delta</span><span class="p">,</span>
                <span class="n">isovalue</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">relative_precision</span><span class="p">,</span>
                <span class="n">mesh_criteria</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Type of isofile &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown. Supported are: &#39;dx&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isofiletype</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">corners</span><span class="p">,</span> <span class="n">face_indices</span><span class="p">,</span> <span class="n">normals</span></div>

<div class="viewcode-block" id="agg.get_surface"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_surface">[docs]</a>    <span class="k">def</span> <span class="nf">get_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a discretized surface of the aggregate according to the current config.</span>

<span class="sd">        Set properties via ManipulateAggregates.aggregate.agg.set_vs beforehand. See</span>
<span class="sd">        ManipulateAggregates.aggregate.agg.default_vs for config options.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tuple of corners,face_indices,normals. corners (a list of lists</span>
<span class="sd">            of 3 floats) contains the Cartesian coordinates of all vertices of</span>
<span class="sd">            the surface. face_indices (list of lists of 3 ints) each triple of</span>
<span class="sd">            integers defines one face of the surface. The indices correspond to</span>
<span class="sd">            corners. normals (list of lists of 3 floats) each triple defines</span>
<span class="sd">            the normal vector associated with the corresponding face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;vdw&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vdw_surface</span><span class="p">(</span>
                <span class="n">nr_refinements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;refine&quot;</span><span class="p">],</span>
                <span class="n">shrink_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;shrink_factor&quot;</span><span class="p">],</span>
                <span class="n">vdwscale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;vdw_scale&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;iso&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iso_surface</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;isovalue&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;isofile&quot;</span><span class="p">],</span>
                <span class="n">isofiletype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;isofiletype&quot;</span><span class="p">],</span>
                <span class="n">mesh_criteria</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;mesh_criteria&quot;</span><span class="p">],</span>
                <span class="n">relative_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;rel_precision&quot;</span><span class="p">],</span>
                <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;iso_atoms&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only iso and van-der-Waals surfaces are supported.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.get_density"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_density">[docs]</a>    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute this aggregate&#39;s electron density at the given coordinates.</span>

<span class="sd">        This function checks whether the last call used the same configuration</span>
<span class="sd">        as the previous one. If that is so, files are not read in again.</span>

<span class="sd">        Args:</span>
<span class="sd">            points: (list of lists of 3 floats) the Cartesian coordinates at</span>
<span class="sd">                which to compute the density </span>

<span class="sd">        Returns:</span>
<span class="sd">            a numpy array of dtype float containing the density values at the</span>
<span class="sd">            specified points</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prog_report</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PROGRESS&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prog_report</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">prog_report</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prog_report</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">)</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1">################################################################################</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;empirical&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute electron density due to empirical charges.&quot;</span>
            <span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;orbitals&quot;</span><span class="p">:</span>
            <span class="n">orbcfg</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;orbfiletype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;orbfile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfile&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">refresh</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orbcfg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">orbcfg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orbcfg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orbcfg</span>
            <span class="c1">###########</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;molden&quot;</span><span class="p">:</span>
                <span class="n">BOHRTOANG</span> <span class="o">=</span> <span class="n">orbitalcharacter</span><span class="o">.</span><span class="n">BOHRTOANG</span>
                <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span>
                        <span class="s2">&quot;orb&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">orbitalcharacter</span><span class="o">.</span><span class="n">read_molden_orbitals_corrected</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfile&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">(</span>
                    <span class="n">basis</span><span class="p">,</span>
                    <span class="n">Smat</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">MOsalpha</span><span class="p">,</span> <span class="n">MOsbeta</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">OCCsalpha</span><span class="p">,</span> <span class="n">OCCsbeta</span><span class="p">),</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orb&quot;</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">InitializeGridCalculationOrbitalsPy</span><span class="p">(</span>
                    <span class="n">corners</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">BOHRTOANG</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unkown orbital file type.&quot;</span><span class="p">)</span>
            <span class="c1">###########</span>
            <span class="k">if</span> <span class="n">MOsalpha</span> <span class="o">==</span> <span class="n">MOsbeta</span><span class="p">:</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">ElectronDensityPy</span><span class="p">(</span>
                        <span class="n">MOsalpha</span><span class="p">,</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">occupations</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">OCCsalpha</span><span class="p">],</span>
                        <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                        <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">ElectronDensityPy</span><span class="p">(</span>
                        <span class="n">MOsalpha</span> <span class="o">+</span> <span class="n">MOsbeta</span><span class="p">,</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">occupations</span><span class="o">=</span><span class="n">OCCsalpha</span> <span class="o">+</span> <span class="n">OCCsbeta</span><span class="p">,</span>
                        <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                        <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;interpolation&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot interpolate electron density.&quot;</span><span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;charges&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot compute electron density from charges.&quot;</span><span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown value for key &#39;type&#39; </span><span class="si">%s</span><span class="s2"> for obtaining the electron density. I know: &#39;orbitals&#39;.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">density</span></div>

<div class="viewcode-block" id="agg.get_potential"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_potential">[docs]</a>    <span class="k">def</span> <span class="nf">get_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute this aggregate&#39;s electrostatic potential at the given coordinates.</span>

<span class="sd">        This function checks whether the last call used the same configuration</span>
<span class="sd">        as the previous one. If that is so, files are not read in again.</span>

<span class="sd">        Args:</span>
<span class="sd">            points: (list of lists of 3 floats) the Cartesian coordinates at</span>
<span class="sd">                which to compute the potential</span>

<span class="sd">        Returns:</span>
<span class="sd">            a numpy array of dtype float containing the potential values at the</span>
<span class="sd">            specified points</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prog_report</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PROGRESS&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prog_report</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">prog_report</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prog_report</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;FireDeamon&quot;</span><span class="p">)</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1">################################################################################</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;empirical&quot;</span><span class="p">:</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_partial_charges</span><span class="p">()</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;partial&quot;</span><span class="p">]:</span>
                <span class="n">charges</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">cc</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_charges</span><span class="p">())]</span>
            <span class="n">potential</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">ElectrostaticPotentialPy</span><span class="p">(</span>
                    <span class="n">points</span><span class="p">,</span> <span class="n">charges</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;orbitals&quot;</span><span class="p">:</span>
            <span class="n">orbcfg</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;orbfiletype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;orbfile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfile&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">refresh</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orbcfg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">orbcfg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orbcfg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orbcfg</span>
            <span class="c1">###########</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;molden&quot;</span><span class="p">:</span>
                <span class="n">BOHRTOANG</span> <span class="o">=</span> <span class="n">orbitalcharacter</span><span class="o">.</span><span class="n">BOHRTOANG</span>
                <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span>
                        <span class="s2">&quot;orb&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">orbitalcharacter</span><span class="o">.</span><span class="n">read_molden_orbitals_corrected</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;orbfile&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">(</span>
                    <span class="n">basis</span><span class="p">,</span>
                    <span class="n">Smat</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">MOsalpha</span><span class="p">,</span> <span class="n">MOsbeta</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">OCCsalpha</span><span class="p">,</span> <span class="n">OCCsbeta</span><span class="p">),</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;orb&quot;</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">InitializeGridCalculationOrbitalsPy</span><span class="p">(</span>
                    <span class="n">corners</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">BOHRTOANG</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unkown orbital file type.&quot;</span><span class="p">)</span>
            <span class="c1">###########</span>
            <span class="k">if</span> <span class="n">MOsalpha</span> <span class="o">==</span> <span class="n">MOsbeta</span><span class="p">:</span>
                <span class="n">potential</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">ElectrostaticPotentialOrbitalsPy</span><span class="p">(</span>
                        <span class="n">MOsalpha</span><span class="p">,</span>
                        <span class="n">Smat</span><span class="p">,</span>
                        <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">OCCsalpha</span><span class="p">],</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">potential</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">ElectrostaticPotentialOrbitalsPy</span><span class="p">(</span>
                        <span class="n">MOsalpha</span> <span class="o">+</span> <span class="n">MOsbeta</span><span class="p">,</span>
                        <span class="n">Smat</span><span class="p">,</span>
                        <span class="n">OCCsalpha</span> <span class="o">+</span> <span class="n">OCCsbeta</span><span class="p">,</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_charges</span><span class="p">()</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
            <span class="n">pospotential</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">ElectrostaticPotentialPy</span><span class="p">(</span>
                    <span class="n">corners</span> <span class="o">/</span> <span class="n">BOHRTOANG</span><span class="p">,</span>
                    <span class="n">charges</span><span class="p">,</span>
                    <span class="p">[[</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">BOHRTOANG</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">],</span>
                    <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">potential</span> <span class="o">+=</span> <span class="n">pospotential</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;interpolation&quot;</span><span class="p">:</span>
            <span class="n">potcfg</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;potfiletype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;potfile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfile&quot;</span><span class="p">],</span>
                <span class="s2">&quot;total_charge&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;total_charge&quot;</span><span class="p">],</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;interpolation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;int_root&quot;</span><span class="p">],</span>
                <span class="s2">&quot;exponent&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;int_exponent&quot;</span><span class="p">],</span>
                <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">refresh</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;potcfg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">potcfg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;potcfg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">potcfg</span>
                <span class="c1">###########</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                    <span class="n">coordinates</span><span class="p">,</span> <span class="n">potential</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_charges_simple</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfile&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;dx&quot;</span><span class="p">:</span>
                    <span class="n">coordinates</span><span class="p">,</span> <span class="n">potential</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_charges_dx</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfile&quot;</span><span class="p">],</span>
                        <span class="n">add_nuclear_charges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">unit_conversion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                        <span class="n">total_charge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;total_charge&quot;</span><span class="p">],</span>
                        <span class="n">invert_charge_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">rescale_charges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cube&quot;</span><span class="p">:</span>
                    <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="n">read_charges_cube</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;potfile&quot;</span><span class="p">],</span>
                        <span class="n">add_nuclear_charges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">rescale_charges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unkown potential file type.&quot;</span><span class="p">)</span>
                <span class="c1">##########</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;pot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">potential</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;pot&quot;</span><span class="p">]</span>
            <span class="c1">###########</span>
            <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;interpolation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;int_root&quot;</span><span class="p">],</span>
                <span class="s2">&quot;exponent&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;int_exponent&quot;</span><span class="p">],</span>
                <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">potential</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">InterpolationPy</span><span class="p">(</span>
                    <span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">potential</span><span class="p">,</span>
                    <span class="n">points</span><span class="p">,</span>
                    <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span><span class="p">,</span>
                    <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;charges&quot;</span><span class="p">:</span>
            <span class="n">chacfg</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;chargefiletype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="s2">&quot;chargefile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefile&quot;</span><span class="p">],</span>
                <span class="s2">&quot;partial&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;partial&quot;</span><span class="p">],</span>
                <span class="s2">&quot;total_charge&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;total_charge&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">refresh</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;chacfg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chacfg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">refresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;chacfg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chacfg</span>
                <span class="c1">###########</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;partial&quot;</span><span class="p">]:</span>
                        <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_charges_simple</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefile&quot;</span><span class="p">],</span> <span class="n">compare_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_charges_simple</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefile&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;dx&quot;</span><span class="p">:</span>
                    <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="n">fdread</span><span class="o">.</span><span class="n">read_charges_dx</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefile&quot;</span><span class="p">],</span>
                        <span class="n">add_nuclear_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">unit_conversion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                        <span class="n">total_charge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;total_charge&quot;</span><span class="p">],</span>
                        <span class="n">invert_charge_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefiletype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cube&quot;</span><span class="p">:</span>
                    <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="n">read_charges_cube</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;chargefile&quot;</span><span class="p">],</span>
                        <span class="n">add_nuclear_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">total_charge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;total_charge&quot;</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="c1">###########</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unkown charge file type.&quot;</span><span class="p">)</span>
                <span class="c1">###########</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;cha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internal__</span><span class="p">[</span><span class="s2">&quot;cha&quot;</span><span class="p">]</span>
            <span class="c1">###########</span>
            <span class="n">potential</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">ElectrostaticPotentialPy</span><span class="p">(</span>
                    <span class="n">points</span><span class="p">,</span> <span class="n">charges</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">prog_report</span><span class="o">=</span><span class="n">prog_report</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1">################################################################################</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown value for key &#39;type&#39; </span><span class="si">%s</span><span class="s2"> for obtaining the electrostatic potential. I know: &#39;empirical&#39;, &#39;orbitals&#39;, &#39;interpolation&#39; and &#39;charges&#39;.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">[</span><span class="s2">&quot;invert_potential&quot;</span><span class="p">]:</span>
            <span class="n">potential</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">potential</span></div>

<div class="viewcode-block" id="agg.get_bond_map"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.get_bond_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">no_hydrogen</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a list of all bonds in a molecule as known by the current force field.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of tuples fo 2 ints, the atom indices associated with the bonds</span>

<span class="sd">        Args:</span>
<span class="sd">            unique: (bool) if True, give back an irreducible list of bonds in the form</span>
<span class="sd">                of tuples of indices.  If False, give back a complete list of bonds, i.e.</span>
<span class="sd">                every atom in a bond is once the first and once the second element in one of</span>
<span class="sd">                the tuples</span>

<span class="sd">            no_hydrogen: (bool) whether or not to exclude hydrogens from the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bondmap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bond_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumBonds</span><span class="p">()):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obmol</span><span class="o">.</span><span class="n">GetBond</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bond_id</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">no_hydrogen</span>
                <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtom</span><span class="p">()</span><span class="o">.</span><span class="n">IsHydrogen</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">GetEndAtom</span><span class="p">()</span><span class="o">.</span><span class="n">IsHydrogen</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">bondmap</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="n">bondmap</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bondmap</span><span class="p">]</span>
            <span class="n">bondmap</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bondmap</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bondmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bondmap</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bondmap</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bondmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">bondmap</span></div>

<div class="viewcode-block" id="agg.visualize"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.visualize">[docs]</a>    <span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Visualize the aggregate according to the currect config.&quot;&quot;&quot;</span>
        <span class="n">visualize</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="agg.rmsd"><a class="viewcode-back" href="../../index.html#ManipulateAggregates.aggregate.agg.rmsd">[docs]</a>    <span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the Root-Mean-Square-Deviation with respect to another aggregate.</span>

<span class="sd">        Args:</span>
<span class="sd">            agg: (of same type) the aggregate to compare agains</span>
<span class="sd">            print_result: (bool) whether or not to also print the result</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_assert_supported</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="n">selftemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="n">othertemp</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="n">selftemp</span><span class="o">.</span><span class="n">align</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">othertemp</span><span class="o">.</span><span class="n">align</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">selfcoords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">selftemp</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">())</span>
        <span class="n">othercoords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">othertemp</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">selfcoords</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">othercoords</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The aggregate to compare against does not have the same number of atoms.&quot;</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">selfcoords</span> <span class="o">-</span> <span class="n">othercoords</span>
        <span class="n">result_rmsd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfcoords</span><span class="p">)))</span>
        <span class="n">result_maxdeviation_single</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
        <span class="n">result_maxdeviation_whole</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">selfcoords</span><span class="p">,</span> <span class="n">othercoords</span>
        <span class="k">del</span> <span class="n">selftemp</span><span class="p">,</span> <span class="n">othertemp</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result_rmsd</span><span class="p">,</span> <span class="n">result_maxdeviation_single</span><span class="p">,</span> <span class="n">result_maxdeviation_whole</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;RMSD: </span><span class="si">%.2e</span><span class="s2"> | Max deviation in one coordinate: </span><span class="si">%.2e</span><span class="s2"> | Max deviation for a single atom: </span><span class="si">%.2e</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="n">result</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Torsten Sachse

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>