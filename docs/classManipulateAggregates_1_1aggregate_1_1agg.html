<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ManipulateAggregates: ManipulateAggregates.aggregate.agg Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceManipulateAggregates.html">ManipulateAggregates</a>.<a class="el" href="namespaceManipulateAggregates_1_1aggregate.html">aggregate</a>.<a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html">agg</a>
  </div>
</div>
<div class="contents">
<h1>ManipulateAggregates.aggregate.agg Class Reference</h1><!-- doxytag: class="ManipulateAggregates::aggregate::agg" -->
<p>The <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a> class (<a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a> stands for <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>).  
<a href="#_details">More...</a></p>

<p><a href="classManipulateAggregates_1_1aggregate_1_1agg-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a6143adf0582740000c09e4e0209644bc">__init__</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a6143adf0582740000c09e4e0209644bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a81f1775b9279bcc91df493c08adb7799">duplicate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate myself or re-read the original file.  <a href="#a81f1775b9279bcc91df493c08adb7799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ac5e6419875bc17fadf9930f902a7f769">get_energy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the energy associated with the current geometry for the current forcefield.  <a href="#ac5e6419875bc17fadf9930f902a7f769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a847b385014767e430491fcc82712eafd">optimize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a sinple geometry optimization using the current forcefield.  <a href="#a847b385014767e430491fcc82712eafd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a97965868d84db75cab5153977b9c01b4">set_cp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an arbitrary configuration option of the dictionary for obtaining charges and potentials.  <a href="#a97965868d84db75cab5153977b9c01b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a2fe86fc969de84c657246e494ca1b2bf">set_vs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an arbitrary configuration option of the dictionary for visualizations and surface generation.  <a href="#a2fe86fc969de84c657246e494ca1b2bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a8217800f487d79be8b46a1a23a745f91">get_cp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an arbitrary configuration option of the dictionary that configures how charges and potentials are obtained.  <a href="#a8217800f487d79be8b46a1a23a745f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#abf57203df7adf2598fca5db01951287a">get_vs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an arbitrary configuration option of the dictionary for visualizations and surface generation.  <a href="#abf57203df7adf2598fca5db01951287a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a356c013731b76014250b462cb09c6161">set_bondlength</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the length of a bond.  <a href="#a356c013731b76014250b462cb09c6161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a11f312ed9367e71f98fccb172e664d4f">get_bondlength</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the length of a bond.  <a href="#a11f312ed9367e71f98fccb172e664d4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a979f59df7bfe5cf953c96ca64d426350">set_angle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the bond angle in deg.  <a href="#a979f59df7bfe5cf953c96ca64d426350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a1ab031961ffad4244b6ff2169b582a03">get_angle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bond angle in deg.  <a href="#a1ab031961ffad4244b6ff2169b582a03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#af2a45e2e0fff7c1c05c6fe707368d1ea">set_dihedral</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the dihedral angle in deg.  <a href="#af2a45e2e0fff7c1c05c6fe707368d1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a0d2a5f9d65223243ee420d4b31fb5ba9">get_dihedral</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dihedral angle in deg.  <a href="#a0d2a5f9d65223243ee420d4b31fb5ba9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aced9e4ec75e889c0247686dac2f1050f">rotate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the molecule around an axis by an angle.  <a href="#aced9e4ec75e889c0247686dac2f1050f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a509bde52696b1d5d04a38a0719dc2c86">rotate_main</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the molecule around one of its main axis by an angle.  <a href="#a509bde52696b1d5d04a38a0719dc2c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a3b97bb281af3c6725dc0c33aea83d5f4">vdw_check</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for van-der-Waals clashes.  <a href="#a3b97bb281af3c6725dc0c33aea83d5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a7b17dc2280977f29b780b164ec6f9e1c">translate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the molecule in a given direction.  <a href="#a7b17dc2280977f29b780b164ec6f9e1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a962034791021a721bbb72ed4ef21d69a">move_closer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move two parts of an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> closer together.  <a href="#a962034791021a721bbb72ed4ef21d69a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef">tag_parts</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage the use of tagging (and thus change the definition of "part").  <a href="#a62a6a4553042bb714cffd318bc1aeaef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a5aeccee23b0a78be5af8f79e33b6e657">append</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a molecule to the current one.  <a href="#a5aeccee23b0a78be5af8f79e33b6e657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a0a07d30b43e8e764dce54fd947a6c925">glue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Glue a molecule to the current one.  <a href="#a0a07d30b43e8e764dce54fd947a6c925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a05b706c87f17e78158b69b5277dc0b58">cleave</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleave a part of a molecule.  <a href="#a05b706c87f17e78158b69b5277dc0b58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a7498e329c0863a03119c355f626ae760">write</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the data of the molecule to disk.  <a href="#a7498e329c0863a03119c355f626ae760"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ae6727a0270e65f479a63f738df8261a1">align</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> in space.  <a href="#ae6727a0270e65f479a63f738df8261a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a7ddd7e4a7d7737f08a27c8b18d5a1c9d">mirror</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mirror or point-invert an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#a7ddd7e4a7d7737f08a27c8b18d5a1c9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#adc77a390fff812449f3f8d29a057428e">part</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an OBMol containing all those atoms that are one one side of a plane.  <a href="#adc77a390fff812449f3f8d29a057428e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ae20146630beba10c5959252cde90a2bc">part_aggregate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object of the same type containing all those atoms that are one one side of a plane.  <a href="#ae20146630beba10c5959252cde90a2bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ab58ac6bc76654e7afb839b41550eac23">get_partial_charges</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of all partial charges of the atoms according to the specified method.  <a href="#ab58ac6bc76654e7afb839b41550eac23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ae50caa7eb7ad679699f19bbc338a232c">set_ecp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an atom's (or of multiple ones) core charge property.  <a href="#ae50caa7eb7ad679699f19bbc338a232c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a4b2bec85493d36b9544a106420ec8801">get_charges</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of all charges of the atoms according to ther element numbers.  <a href="#a4b2bec85493d36b9544a106420ec8801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a5866638d36b86e94e17724b8d006d554">get_dipole_moment</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an aggregate's electric dipole moment from point charges.  <a href="#a5866638d36b86e94e17724b8d006d554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a19110dd6e5b87ca3e9a3bf342f0f3a40">get_coordinates</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the coordinates of all atoms.  <a href="#a19110dd6e5b87ca3e9a3bf342f0f3a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a8b5fbebd84459ede43d6ae8f53d91ee3">get_center</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the non-mass-weighted center of the molecule.  <a href="#a8b5fbebd84459ede43d6ae8f53d91ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ac3ade01d7e00116a895b1eaff4486bbb">get_main_axes</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last 2 main axes of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#ac3ade01d7e00116a895b1eaff4486bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a074dc40fb736d4217919128d6af52f06">get_align_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a matrix to align the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#a074dc40fb736d4217919128d6af52f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a88e2d93cf8b1adc131c5bcd55473e836">get_vdw_radii</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all van-der-Waals radii for the atoms in this <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#a88e2d93cf8b1adc131c5bcd55473e836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a5497b2b93c5d9965be5ba1a1391601e1">get_names</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of all element symbols of the atoms.  <a href="#a5497b2b93c5d9965be5ba1a1391601e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a3b8961edb7142be75fac669e3a6b7c89">get_colours</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of colors associated with the element symbols of the atoms.  <a href="#a3b8961edb7142be75fac669e3a6b7c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a0f2ef9db47e7faea89ba4ad78adcbd8d">get_masses</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of masses associated with the element symbols of the atoms.  <a href="#a0f2ef9db47e7faea89ba4ad78adcbd8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a4f0b7e12de672ba87d34d376c9c1a997">get_vdw_surface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the aggregate's discretized van-der-Waals surface.  <a href="#a4f0b7e12de672ba87d34d376c9c1a997"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a411128c917e5f67ca6afe2ecd2839e8b">get_iso_surface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a discretized iso surface of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#a411128c917e5f67ca6afe2ecd2839e8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a907eab77f6329ed0fe4f440b2b26fa51">get_surface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a discretized surface of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> according to the current config.  <a href="#a907eab77f6329ed0fe4f440b2b26fa51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a0d2dd89f82f68218a3d1b8d091ca74ee">get_density</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute this aggregate's electron density at the given coordinates.  <a href="#a0d2dd89f82f68218a3d1b8d091ca74ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a87ad7a0d1d36330686b4b0c235cd3ff7">get_potential</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute this aggregate's electrostatic potential at the given coordinates.  <a href="#a87ad7a0d1d36330686b4b0c235cd3ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a04be73e9e53de2929f6451f06b91cf8f">get_bond_map</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce a list of all bonds in a molecule as known by the current force field.  <a href="#a04be73e9e53de2929f6451f06b91cf8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#ab8bf51463f4e2298cb5fe5ddec3135e0">visualize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visualize the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> according to the currect config.  <a href="#ab8bf51463f4e2298cb5fe5ddec3135e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a6b53faf34a2c5501e17b34971aeffc7b">rmsd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the Root-Mean-Square-Deviation with respect to another <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>.  <a href="#a6b53faf34a2c5501e17b34971aeffc7b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a1a3588681f2a0ec56786d87a7b2c17e2">obmol</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(of type OBAggregate) the underlying OpenBabel data structure  <a href="#a1a3588681f2a0ec56786d87a7b2c17e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a4988c22a78c3fd03d96ca39e8ffe526a">info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(dictionary) contains information about the file this object was created from  <a href="#a4988c22a78c3fd03d96ca39e8ffe526a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a399c82e94ad61a609e12959a1a44d1b2">cp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(dictionary) contains information about how to obtain this molecule's charges and potentials  <a href="#a399c82e94ad61a609e12959a1a44d1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#acec8fc3f0c0c08cb85bfa6235b5740e6">vs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(dictionary) contains information about desired visualizations and surface generation  <a href="#acec8fc3f0c0c08cb85bfa6235b5740e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a60e64905fe9b3a196cea35fd85a70c56">ff</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(OBForceField) the underlying OpenBabel force field data structure  <a href="#a60e64905fe9b3a196cea35fd85a70c56"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9e5c1b1f7b1ec6b678c06a59659bdcb">default_vs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default config options for surface generation and visualization.  <a href="#aa9e5c1b1f7b1ec6b678c06a59659bdcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9a0f03a5fdb3d7748b6645bdb6d1bfc">default_cp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default config options for obtaining charges and electrostatic potentials.  <a href="#aa9a0f03a5fdb3d7748b6645bdb6d1bfc"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a> class (<a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a> stands for <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>). </p>
<p>This class is:</p>
<ol type="1">
<li>a Python wrapper for the OBAggregate class of the modified OpenBabel version providing pythonic methods that are not very easy to use via OpenBabel's language bindings</li>
<li>an extension to the above in the sense that, by interfacing with the other submodules of <a class="el" href="namespaceManipulateAggregates.html" title="The top-level module ManipulateAggregates.">ManipulateAggregates</a>, additional functionality is provided, such as:<ul>
<li>estimation of the HLB value</li>
<li>visualization of an electrostatic potential on a molecular surface</li>
</ul>
</li>
</ol>
<ol type="1">
<li>the base class used for the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> geometry estimation implemented in the submodule <a class="el" href="namespaceManipulateAggregates_1_1energyscan.html" title="Create low-energy aggregates from molecules.">ManipulateAggregates.energyscan</a> </li>
</ol>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6143adf0582740000c09e4e0209644bc"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::__init__" ref="a6143adf0582740000c09e4e0209644bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.__init__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>obmol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ff</em> = <code>'mmff94'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>info</em> = <code>{}</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obmol</em>&nbsp;</td><td>(OBAggregate) the underlying OpenBabel data structure, will be copied</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ff</em>&nbsp;</td><td>(string) declare the forcefield associated with the molecule. Needed to get the energy and perform a simple forcefield geometry optimization. Run "obabel -L forcefields" to get supported ones. Can also be None (switched off) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>(dictionary) has keys 'name' and 'format' detailing the filename and format, respectively. Also, the keys 'conf_nr' and 'ff' for the used conformer number and force field are required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6727a0270e65f479a63f738df8261a1"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::align" ref="ae6727a0270e65f479a63f738df8261a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.align </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>main3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>main2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Align an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> in space. </p>
<p>Align the last two main axes of an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> to the two given axes and move the center to the given coordinate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>(list of 3 floats) the new center of the molecule (not mass weighed) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>main3</em>&nbsp;</td><td>(list of 3 floats) the new 3rd main axis (usually the longest extent) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>main2</em>&nbsp;</td><td>(list of 3 floats) the new 2nd main axis</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>(None or int&gt;=0) if an integer is provided, only treat that part. Please see <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a> for a definition of "part". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aeccee23b0a78be5af8f79e33b6e657"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::append" ref="a5aeccee23b0a78be5af8f79e33b6e657" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.append </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vector</em> = <code>[0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>axis</em> = <code>[1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a molecule to the current one. </p>
<p>"Appending" means that all the atoms and bonds contained within <em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em> are added (deep-dopied, i.e., you can detele <em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em> afterwards) to the current molecule. No new bonds are formed. Before appending, translate and rotate <em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em>&nbsp;</td><td><a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> to be appended (of the same type)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vector</em>&nbsp;</td><td>(list of 3 floats) translate <em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em> by this vector prior to appending it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>(list of 3 floats) rotate <em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em> around this axis prior to appending it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>(float) the angle for the rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05b706c87f17e78158b69b5277dc0b58"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::cleave" ref="a05b706c87f17e78158b69b5277dc0b58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.cleave </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleave a part of a molecule. </p>
<p>Cleave all atoms and bonds that are connected to the atom indexed by <em>i2</em> but not to <em>i1</em>. Leave the rest as it is.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i1</em>&nbsp;</td><td>(int) index specifying the atom of the molecule that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i2</em>&nbsp;</td><td>(int) index specifying the atom of the molecule that will not be retained </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81f1775b9279bcc91df493c08adb7799"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::duplicate" ref="a81f1775b9279bcc91df493c08adb7799" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.duplicate </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>read_file</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate myself or re-read the original file. </p>
<p>Please be aware that the constructor is called again. The __internal__ dictionary is only shallowly copied, all the others are deep copies.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>read_file</em>&nbsp;</td><td>if True, the original file is read in again instead of duplicating the molecule as it is.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>object of <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">ManipulateAggregates.aggregate.agg</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a074dc40fb736d4217919128d6af52f06"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_align_matrix" ref="a074dc40fb736d4217919128d6af52f06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_align_matrix </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>main3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>main2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a matrix to align the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<p>Return the composite rotation matrix that would align the third and second main axes to the given axes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>main3</em>&nbsp;</td><td>(list of 3 floats) the new 3rd main axis (usually the longest extent) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>main2</em>&nbsp;</td><td>(list of 3 floats) the new 2nd main axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a numpy array of shape (3,3) and dtype float, the rotation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab031961ffad4244b6ff2169b582a03"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_angle" ref="a1ab031961ffad4244b6ff2169b582a03" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_angle </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the bond angle in deg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx3</em>&nbsp;</td><td>(int) number of third atom that defines the angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the angle defined by the three atoms in degrees </dd></dl>

</div>
</div>
<a class="anchor" id="a04be73e9e53de2929f6451f06b91cf8f"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_bond_map" ref="a04be73e9e53de2929f6451f06b91cf8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_bond_map </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>unique</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>no_hydrogen</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a list of all bonds in a molecule as known by the current force field. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of tuples fo 2 ints, the atom indices associated with the bonds</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unique</em>&nbsp;</td><td>(bool) if True, give back an irreducible list of bonds in the form of tuples of indices. If False, give back a complete list of bonds, i.e. every atom in a bond is once the first and once the second element in one of the tuples </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_hydrogen</em>&nbsp;</td><td>(bool) whether or not to exclude hydrogens from the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11f312ed9367e71f98fccb172e664d4f"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_bondlength" ref="a11f312ed9367e71f98fccb172e664d4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_bondlength </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>projection</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the length of a bond. </p>
<p>There does not actually have to be a bond between the given atoms. If <em>projection</em> is not None, the bond will be projected onto the given vector and the length of that projection will be given.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the bond </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the bond</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>projection</em>&nbsp;</td><td>(list of 3 floats) projection vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(possibly projected) bond length </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5fbebd84459ede43d6ae8f53d91ee3"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_center" ref="a8b5fbebd84459ede43d6ae8f53d91ee3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_center </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the non-mass-weighted center of the molecule. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of 3 floats, the Cartesian coordinates of the center </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2bec85493d36b9544a106420ec8801"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_charges" ref="a4b2bec85493d36b9544a106420ec8801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_charges </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ecp</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a list of all charges of the atoms according to ther element numbers. </p>
<p>This function respects the atom property "ecp" that might be stored in each of the OBAtom objects, if <em>ecp</em> is True.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ecp</em>&nbsp;</td><td>(bool) whether or not to respect the core charge property</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of floats containing the elemental charges (possibly minus core charges). </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8961edb7142be75fac669e3a6b7c89"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_colours" ref="a3b8961edb7142be75fac669e3a6b7c89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_colours </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of colors associated with the element symbols of the atoms. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of tuples of 3 floats, RGB values </dd></dl>

</div>
</div>
<a class="anchor" id="a19110dd6e5b87ca3e9a3bf342f0f3a40"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_coordinates" ref="a19110dd6e5b87ca3e9a3bf342f0f3a40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_coordinates </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the coordinates of all atoms. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of lists of 3 floats, the Cartesian coordinates of the atoms </dd></dl>

</div>
</div>
<a class="anchor" id="a8217800f487d79be8b46a1a23a745f91"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_cp" ref="a8217800f487d79be8b46a1a23a745f91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_cp </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an arbitrary configuration option of the dictionary that configures how charges and potentials are obtained. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>(string) the property whose value you want to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value associated with <em>key</em> or None if the key is not present </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2dd89f82f68218a3d1b8d091ca74ee"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_density" ref="a0d2dd89f82f68218a3d1b8d091ca74ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_density </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>points</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute this aggregate's electron density at the given coordinates. </p>
<p>This function checks whether the last call used the same configuration as the previous one. If that is so, files are not read in again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>(list of lists of 3 floats) the Cartesian coordinates at which to compute the density</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a numpy array of dtype float containing the density values at the specified points </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2a5f9d65223243ee420d4b31fb5ba9"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_dihedral" ref="a0d2a5f9d65223243ee420d4b31fb5ba9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_dihedral </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dihedral angle in deg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx3</em>&nbsp;</td><td>(int) number of third atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx4</em>&nbsp;</td><td>(int) number of fourth atom that defines the dihedral angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the dihedral angle defined by the four atoms in degrees </dd></dl>

</div>
</div>
<a class="anchor" id="a5866638d36b86e94e17724b8d006d554"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_dipole_moment" ref="a5866638d36b86e94e17724b8d006d554" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_dipole_moment </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an aggregate's electric dipole moment from point charges. </p>
<p>The currently set method for obtaining partial charges will be used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of 3 floats, the electric dipole vector </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e6419875bc17fadf9930f902a7f769"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_energy" ref="ac5e6419875bc17fadf9930f902a7f769" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_energy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>unit</em> = <code>&quot;meV&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the energy associated with the current geometry for the current forcefield. </p>
<p>Units can be specified. Supported units are "kJ/mol", "kcal/mol" and "meV".</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>energy in the specified units. </dd></dl>

</div>
</div>
<a class="anchor" id="a411128c917e5f67ca6afe2ecd2839e8b"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_iso_surface" ref="a411128c917e5f67ca6afe2ecd2839e8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_iso_surface </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>isofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>isofiletype</em> = <code>&quot;dx&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mesh_criteria</em> = <code><a class="el" href="namespaceManipulateAggregates_1_1aggregate.html#aa2a05f97e32f2c32a1996d981fb5db89">MESH_CRITERIA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>relative_precision</em> = <code>1.0e-06</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>atoms</em> = <code>&quot;auto&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a discretized iso surface of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<p>Do not call directly. Rather use <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a907eab77f6329ed0fe4f440b2b26fa51" title="Compute a discretized surface of the aggregate according to the current config.">ManipulateAggregates.aggregate.agg.get_surface</a> and set properties via <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a2fe86fc969de84c657246e494ca1b2bf" title="Set an arbitrary configuration option of the dictionary for visualizations and surface...">ManipulateAggregates.aggregate.agg.set_vs</a> beforehand. Please see <a href="http://doc.cgal.org/latest/Surface_mesher/index.html">http://doc.cgal.org/latest/Surface_mesher/index.html</a> for more information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isovalue</em>&nbsp;</td><td>(float) the isovalue for the surface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isofile</em>&nbsp;</td><td>(string) path to the file from which to take the volumetric data</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isofiletype</em>&nbsp;</td><td>(string) filetype of the volumetric data file. Only "dx" is supported as of now. "cube" might be added later. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mesh_criteria</em>&nbsp;</td><td>(list of 3 floats) CGAL's internal meshing criteria </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relative_precision</em>&nbsp;</td><td>(float) CGAL's internal precision for meshing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>atoms</em>&nbsp;</td><td>(int, list of ints or "all" or "noH" or "auto") CGAL's mesh generation requires a point inside the isosurface. For a chemical compound, all atoms should lie within the isosurface. For aggregates, this is not the case. Here, specofy at least one atom of every covalently bound unit. The special values "all" and "noH" select all atoms or only non-hydrogen atoms. The special value "auto" automatically uses the first atom of each covalently bound unit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of corners,face_indices,normals. corners (a list of lists of 3 floats) contains the Cartesian coordinates of all vertices of the surface. face_indices (list of lists of 3 ints) each triple of integers defines one face of the surface. The indices correspond to <em>corners</em>. normals (list of lists of 3 floats) each triple defines the normal vector associated with the corresponding face. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3ade01d7e00116a895b1eaff4486bbb"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_main_axes" ref="ac3ade01d7e00116a895b1eaff4486bbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_main_axes </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the last 2 main axes of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of 2 lists of 3 floats, the third and second main axes </dd></dl>

</div>
</div>
<a class="anchor" id="a0f2ef9db47e7faea89ba4ad78adcbd8d"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_masses" ref="a0f2ef9db47e7faea89ba4ad78adcbd8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_masses </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of masses associated with the element symbols of the atoms. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of floats, the masses in atomic units </dd></dl>

</div>
</div>
<a class="anchor" id="a5497b2b93c5d9965be5ba1a1391601e1"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_names" ref="a5497b2b93c5d9965be5ba1a1391601e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_names </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of all element symbols of the atoms. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of strings, the element symbols of the atoms. </dd></dl>

</div>
</div>
<a class="anchor" id="ab58ac6bc76654e7afb839b41550eac23"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_partial_charges" ref="ab58ac6bc76654e7afb839b41550eac23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_partial_charges </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of all partial charges of the atoms according to the specified method. </p>
<p>The returned list has the same order as the atoms in the molecule.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of floats containing the partial charges.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ValueError</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ManipulateAggregates.aggregate.OpenBabelError.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87ad7a0d1d36330686b4b0c235cd3ff7"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_potential" ref="a87ad7a0d1d36330686b4b0c235cd3ff7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_potential </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>points</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute this aggregate's electrostatic potential at the given coordinates. </p>
<p>This function checks whether the last call used the same configuration as the previous one. If that is so, files are not read in again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>(list of lists of 3 floats) the Cartesian coordinates at which to compute the potential</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a numpy array of dtype float containing the potential values at the specified points </dd></dl>

</div>
</div>
<a class="anchor" id="a907eab77f6329ed0fe4f440b2b26fa51"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_surface" ref="a907eab77f6329ed0fe4f440b2b26fa51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_surface </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a discretized surface of the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> according to the current config. </p>
<p>Set properties via <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a2fe86fc969de84c657246e494ca1b2bf" title="Set an arbitrary configuration option of the dictionary for visualizations and surface...">ManipulateAggregates.aggregate.agg.set_vs</a> beforehand. See <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9e5c1b1f7b1ec6b678c06a59659bdcb" title="Default config options for surface generation and visualization.">ManipulateAggregates.aggregate.agg.default_vs</a> for config options.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of corners,face_indices,normals. corners (a list of lists of 3 floats) contains the Cartesian coordinates of all vertices of the surface. face_indices (list of lists of 3 ints) each triple of integers defines one face of the surface. The indices correspond to <em>corners</em>. normals (list of lists of 3 floats) each triple defines the normal vector associated with the corresponding face. </dd></dl>

</div>
</div>
<a class="anchor" id="a88e2d93cf8b1adc131c5bcd55473e836"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_vdw_radii" ref="a88e2d93cf8b1adc131c5bcd55473e836" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_vdw_radii </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all van-der-Waals radii for the atoms in this <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of floats, van-der-Waals radii of the atoms according to the element table of OpenBabel </dd></dl>

</div>
</div>
<a class="anchor" id="a4f0b7e12de672ba87d34d376c9c1a997"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_vdw_surface" ref="a4f0b7e12de672ba87d34d376c9c1a997" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_vdw_surface </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_refinements</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>shrink_factor</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vdwscale</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the aggregate's discretized van-der-Waals surface. </p>
<p>Do not call directly. Rather use <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a907eab77f6329ed0fe4f440b2b26fa51" title="Compute a discretized surface of the aggregate according to the current config.">ManipulateAggregates.aggregate.agg.get_surface</a> and set properties via <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a2fe86fc969de84c657246e494ca1b2bf" title="Set an arbitrary configuration option of the dictionary for visualizations and surface...">ManipulateAggregates.aggregate.agg.set_vs</a> beforehand.</p>
<p>Uses CGAL's skin surface mesher. Please see <a href="http://doc.cgal.org/latest/Skin_surface_3/index.html">http://doc.cgal.org/latest/Skin_surface_3/index.html</a> for more information on this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nr_refinements</em>&nbsp;</td><td>(int) number of refinement steps for the skin surface generation. The higher the number the more vertices it will have. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shrink_factor</em>&nbsp;</td><td>the shrink factor for the generation of the skin surface. Must be between 0 and 1 (not including those). The bigger the value the tighter the surface will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vdwscale</em>&nbsp;</td><td>(float) multiply each vdW radius by this value before building the surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of corners,face_indices,normals. corners (a list of lists of 3 floats) contains the Cartesian coordinates of all vertices of the surface. face_indices (list of lists of 3 ints) each triple of integers defines one face of the surface. The indices correspond to <em>corners</em>. normals (list of lists of 3 floats) each triple defines the normal vector associated with the corresponding face.</dd></dl>
<p>Example in 2D for nr_points=12 <br/>
 . : point on the sphere's surface <br/>
 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>X center of the sphere <br/>
</dd></dl>
<p>Not overlapping =&gt; 12 points per sphere </p>
<div class="fragment"><pre class="fragment">            ...   ...
           .   . .   .
           . X . . X .
           .   . .   .
            ...   ...
</pre></div><p> Overlapping =&gt; points that would be within the other sphere are removed =&gt; 9 points per "sphere" </p>
<div class="fragment"><pre class="fragment"> @<span class="keywordflow">return</span>                    ......
           .      .
           . X  X .
           .      .
 @<span class="keywordflow">return</span>                    ......
</pre></div> 
</div>
</div>
<a class="anchor" id="abf57203df7adf2598fca5db01951287a"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::get_vs" ref="abf57203df7adf2598fca5db01951287a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.get_vs </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an arbitrary configuration option of the dictionary for visualizations and surface generation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>(string) the property whose value you want to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value associated with <em>key</em> or None if the key is not present </dd></dl>

</div>
</div>
<a class="anchor" id="a0a07d30b43e8e764dce54fd947a6c925"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::glue" ref="a0a07d30b43e8e764dce54fd947a6c925" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.glue </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Glue a molecule to the current one. </p>
<p>Two bonds, one in each involved molecule, will be cut in half and then glued together in such a way, that all atoms connected to <em>i2</em> and <em>m2</em> (including those two) but not connected to <em>i1</em> and <em>m1</em> will be cleaved and the molecules will be glued together so that <em>i1</em> and <em>m1</em> form a proper bond.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em>&nbsp;</td><td><a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> to be glued to this one (of same type) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i1</em>&nbsp;</td><td>(int) index specifying the atom of the primary molecule that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i2</em>&nbsp;</td><td>(int) index specifying the atom of the primary molecule that will not be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>(int) index specifying the atom of the secondary molecule that will be retained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m2</em>&nbsp;</td><td>(int) index specifying the atom of the secondary molecule that will not be retained </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ddd7e4a7d7737f08a27c8b18d5a1c9d"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::mirror" ref="a7ddd7e4a7d7737f08a27c8b18d5a1c9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.mirror </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>center_it</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mirror or point-invert an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<p>Mirror the molecule either by point inversion or by mirroring at a plane.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>(list of 3 floats) the normal vector of the mirror plane. If its norm is 0, point inversion will be performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>(list of 3 floats) either the inversion point or a point in the plane (Hessian normal form)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_it</em>&nbsp;</td><td>(bool) whether or not the entire aggregate's center shall be moved to the origin prior to the operation. The center will automatically be moved back to its original position afterward the procedure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>(None or int&gt;=0) if an integer is provided, only treat that part. Please see <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a> for a definition of "part". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a962034791021a721bbb72ed4ef21d69a"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::move_closer" ref="a962034791021a721bbb72ed4ef21d69a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.move_closer </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>stepsize</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vdw_factor</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vdw_added</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move two parts of an <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> closer together. </p>
<p>The parts are moved closer together until a clash of vdW surfaces occurs. Indices start at 1. A "part" is one covalently bound unit as determined by the force field. If tagging was enabled using <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a>, a "part" is one tagged unit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>part1</em>&nbsp;</td><td>(int) index indicating the first part in the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> that shall be moved closer to another one </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part2</em>&nbsp;</td><td>(int) second index</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stepsize</em>&nbsp;</td><td>(float) stepsize for movement (good value: 0.2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vdw_factor</em>&nbsp;</td><td>(float) factor by which all vdW-radii will be multiplied before detecting clashes (default: 0.9) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vdw_added</em>&nbsp;</td><td>(float) value that is added to all vdW-radii before detecting clashes (default: 0.0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>(None or list of 3 floats) if not None, the parts will be moved closer together in the direction of this vector. Otherwise, the parts will be moved closer along the vector connecting their non-mass-weighted centers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a847b385014767e430491fcc82712eafd"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::optimize" ref="a847b385014767e430491fcc82712eafd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.optimize </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>steps</em> = <code>500</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a sinple geometry optimization using the current forcefield. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>steps</em>&nbsp;</td><td>(int) number of optimization steps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc77a390fff812449f3f8d29a057428e"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::part" ref="adc77a390fff812449f3f8d29a057428e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.part </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an OBMol containing all those atoms that are one one side of a plane. </p>
<p>The plane is given in the Hessian normal form.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>normal_vector</em>&nbsp;</td><td>(list of 3 floats) the normal vector of the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>(list of 3 floats) a point in the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae20146630beba10c5959252cde90a2bc"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::part_aggregate" ref="ae20146630beba10c5959252cde90a2bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.part_aggregate </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>side</em> = <code>'left'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an object of the same type containing all those atoms that are one one side of a plane. </p>
<p>The plane is given in the Hessian normal form. Please note that the contructor will be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>normal_vector</em>&nbsp;</td><td>(list of 3 floats) the normal vector of the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>(list of 3 floats) a point in the plane</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>(string) If 'left', select those atoms on the side where the normal vector points. If anything else, select all those on the opposite side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b53faf34a2c5501e17b34971aeffc7b"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::rmsd" ref="a6b53faf34a2c5501e17b34971aeffc7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.rmsd </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>print_result</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the Root-Mean-Square-Deviation with respect to another <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">agg</a></em>&nbsp;</td><td>(of same type) the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> to compare agains</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>print_result</em>&nbsp;</td><td>(bool) whether or not to also print the result</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ValueError.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aced9e4ec75e889c0247686dac2f1050f"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::rotate" ref="aced9e4ec75e889c0247686dac2f1050f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.rotate </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the molecule around an axis by an angle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>(list of 3 floats) rotate the geometry around this axis </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>(float) the angle for the rotation (in degrees)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>(None or int&gt;=0) if an integer is provided, only treat that part. Please see <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a> for a definition of "part". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a509bde52696b1d5d04a38a0719dc2c86"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::rotate_main" ref="a509bde52696b1d5d04a38a0719dc2c86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.rotate_main </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>axis_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the molecule around one of its main axis by an angle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis_index</em>&nbsp;</td><td>(int, 1, 2 or 3) the index of the main axis to rotate around </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>(float) the angle for the rotation</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>(None or int&gt;=0) if an integer is provided, only treat that part. Please see <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a> for a definition of "part". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a979f59df7bfe5cf953c96ca64d426350"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_angle" ref="a979f59df7bfe5cf953c96ca64d426350" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_angle </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the bond angle in deg. </p>
<p>If the angle connects two parts of a molecule that are otherwise not connected, those parts are moved with the respective atom. See <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a356c013731b76014250b462cb09c6161" title="Adjust the length of a bond.">ManipulateAggregates.aggregate.agg.set_bondlength</a> for a graphical example.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx3</em>&nbsp;</td><td>(int) number of third atom that defines the angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>(float) the new angle (in degrees) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a356c013731b76014250b462cb09c6161"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_bondlength" ref="a356c013731b76014250b462cb09c6161" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_bondlength </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>fix</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adjust the length of a bond. </p>
<p>If the bond connects two parts of a molecule that are otherwise not connected, those parts are moved with the respective atom. Otherwise, move only the 2 given atoms. There does not actually have to be a bond between the given atoms.</p>
<p>Example original geometry </p>
<div class="fragment"><pre class="fragment">           _   _
          |_|-|_|
</pre></div><p> Adjust the middle bond to 3 times it's original length </p>
<div class="fragment"><pre class="fragment">          _     _
         |_|---|_|
</pre></div><p> Please note how both squares were moved along with the atoms comprising the bond.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the bond </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the bond </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>(float) the new bond length (in Angstroms)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fix</em>&nbsp;</td><td>(1 or 2 or None) keep the first or second atom fixed and move only the other. if it is None, move both by half the required distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97965868d84db75cab5153977b9c01b4"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_cp" ref="a97965868d84db75cab5153977b9c01b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_cp </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an arbitrary configuration option of the dictionary for obtaining charges and potentials. </p>
<p>If <em>key</em> and <em>value</em> are lists , key-value pairs will be assigned. If the lists are of unequal lenghts (e.g., n and n+m), only the first n key-value pairs will be treated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>(string) the property (or properties) to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>(appropriate) the data associated with the key(s). See <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9a0f03a5fdb3d7748b6645bdb6d1bfc" title="Default config options for obtaining charges and electrostatic potentials.">ManipulateAggregates.aggregate.agg.default_cp</a> for possible options and values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2a45e2e0fff7c1c05c6fe707368d1ea"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_dihedral" ref="af2a45e2e0fff7c1c05c6fe707368d1ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_dihedral </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the dihedral angle in deg. </p>
<p>If the angle connects two parts of a molecule that are otherwise not connected, those parts are moved with the respective atom. See <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a356c013731b76014250b462cb09c6161" title="Adjust the length of a bond.">ManipulateAggregates.aggregate.agg.set_bondlength</a> for a graphical example.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx1</em>&nbsp;</td><td>(int) number of first atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx2</em>&nbsp;</td><td>(int) number of second atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx3</em>&nbsp;</td><td>(int) number of third atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx4</em>&nbsp;</td><td>(int) number of fourth atom that defines the dihedral angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>(float) the new angle (in degrees) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae50caa7eb7ad679699f19bbc338a232c"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_ecp" ref="ae50caa7eb7ad679699f19bbc338a232c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_ecp </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ecp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an atom's (or of multiple ones) core charge property. </p>
<p>If <em>idx</em> and <em>ecp</em> are iterables, idx-ecp pairs will be assigned. If the iterables are of unequal lenghts (e.g., n and n+m), only the first n key-value pairs will be treated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>(int or iterable of ints) the id(s) (starting at 1) of the atom whose ecp shall be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ecp</em>&nbsp;</td><td>(int or iterable of ints) the cored charge(s) of the atom whose ecp shall be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fe86fc969de84c657246e494ca1b2bf"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::set_vs" ref="a2fe86fc969de84c657246e494ca1b2bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.set_vs </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an arbitrary configuration option of the dictionary for visualizations and surface generation. </p>
<p>If <em>key</em> and <em>value</em> are lists, key-value pairs will be assigned. If the lists are of unequal lenghts (e.g., n and n+m), only the first n key-value pairs will be treated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>(string or list of strings) the property (or properties) to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>(appropriate) the data associated with the key(s). See <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9e5c1b1f7b1ec6b678c06a59659bdcb" title="Default config options for surface generation and visualization.">ManipulateAggregates.aggregate.agg.default_vs</a> for possible options and values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62a6a4553042bb714cffd318bc1aeaef"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::tag_parts" ref="a62a6a4553042bb714cffd318bc1aeaef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.tag_parts </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>verbose</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manage the use of tagging (and thus change the definition of "part"). </p>
<p>Enable, disable or manage tagging. Part indices start at 0. A "part" is one covalently bound unit as determined by the force field. If tagging was enabled, a "part" is one tagged unit.</p>
<p>If <em>parts</em> is a list of integers, the molecules that are indexed with the numbers in this list are together added to one tag and tagging is enabled for the entire <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a>. If parts is &lt;0, tagging is disabled. If parts is &gt;0, tagging is enabled (and nothing else happens). If parts is 0, only tagging information is printed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parts</em>&nbsp;</td><td>(int or list of ints) see detailed description</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verbose</em>&nbsp;</td><td>(bool) whether or not information about what was changed shall be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index that, from now on, can be used to treat the here tagged unit, or None if no tagging was changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b17dc2280977f29b780b164ec6f9e1c"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::translate" ref="a7b17dc2280977f29b780b164ec6f9e1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.translate </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>part</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translate the molecule in a given direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vector</em>&nbsp;</td><td>(list of 3 floats) vector that is added to every atom's coordinate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>(None or int&gt;0=) if an integer is provided, only treat that part. Please see <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a62a6a4553042bb714cffd318bc1aeaef" title="Manage the use of tagging (and thus change the definition of &quot;part&quot;).">ManipulateAggregates.aggregate.agg.tag_parts</a> for a definition of "part". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b97bb281af3c6725dc0c33aea83d5f4"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::vdw_check" ref="a3b97bb281af3c6725dc0c33aea83d5f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.vdw_check </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>factor</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for van-der-Waals clashes. </p>
<p>Check whether any two atoms are closer together than the sum of their van-der-Vaals radii. Perform this check only for atoms that are not connected by an arbitrary number of bonds. Hence, this only makes sense for aggregates.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factor</em>&nbsp;</td><td>(float) before checking for clashes, each van-der-Waals radius is multiplied by this factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether or not any two atoms clash </dd></dl>

</div>
</div>
<a class="anchor" id="ab8bf51463f4e2298cb5fe5ddec3135e0"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::visualize" ref="ab8bf51463f4e2298cb5fe5ddec3135e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.visualize </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Visualize the <a class="el" href="namespaceManipulateAggregates_1_1aggregate.html" title="Definitions of the agg class and some auxilliary function.">aggregate</a> according to the currect config. </p>

</div>
</div>
<a class="anchor" id="a7498e329c0863a03119c355f626ae760"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::write" ref="a7498e329c0863a03119c355f626ae760" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.agg.write </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>fileformat</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>overwrite</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the data of the molecule to disk. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>(string) path to the file (INCLUDING the extension)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileformat</em>&nbsp;</td><td>(string) output file format (anything that openbabel can write) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overwrite</em>&nbsp;</td><td>shall the output file be overwritten or not</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ManipulateAggregates.aggregate.MissingModuleError.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a399c82e94ad61a609e12959a1a44d1b2"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::cp" ref="a399c82e94ad61a609e12959a1a44d1b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a399c82e94ad61a609e12959a1a44d1b2">ManipulateAggregates::aggregate.agg::cp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(dictionary) contains information about how to obtain this molecule's charges and potentials </p>

</div>
</div>
<a class="anchor" id="aa9a0f03a5fdb3d7748b6645bdb6d1bfc"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::default_cp" ref="aa9a0f03a5fdb3d7748b6645bdb6d1bfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9a0f03a5fdb3d7748b6645bdb6d1bfc">ManipulateAggregates.aggregate.agg.default_cp</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">{
        <span class="comment"># How the electrostatic potential shall be obtained. The value &quot;empirical&quot; uses empirical</span>
        <span class="comment"># methods implemented in OpenBabel (generation of partial charges, which are then used to</span>
        <span class="comment"># compute the potential) (fastest method). The value &quot;orbitals&quot; uses information from</span>
        <span class="comment"># quantum mechanical orbitals to compute the potential (most accurate method). The value</span>
        <span class="comment"># &quot;interpolation&quot; interpolates a given electrostatic potential onto new points in space. The</span>
        <span class="comment"># value &quot;charge&quot; uses externally provided charges instead of, e.g., empirically determined</span>
        <span class="comment"># ones and then computes the potential.</span>
        <span class="stringliteral">&quot;type&quot;</span>             : <span class="stringliteral">&quot;empirical&quot;</span>,   <span class="comment"># &quot;empirical&quot;, &quot;orbitals&quot;, &quot;interpolation&quot; or &quot;charges&quot;</span>
        <span class="comment"># How empirical charges shall be obtained. Everything supported by OpenBabel is supported.</span>
        <span class="stringliteral">&quot;method&quot;</span>           : <span class="stringliteral">&quot;mmff94&quot;</span>,      <span class="comment"># string</span>
        <span class="comment"># Whether or not charges obtained using empirical methods are partial charges or not.</span>
        <span class="stringliteral">&quot;partial&quot;</span>          : <span class="keyword">True</span>,          <span class="comment"># bool</span>
        <span class="comment"># The type of file in which the quantum mechanical orbital data is stored.</span>
        <span class="stringliteral">&quot;orbfiletype&quot;</span>      : <span class="stringliteral">&quot;molden&quot;</span>,      <span class="comment"># only &quot;molden&quot; supported so far</span>
        <span class="comment"># The path to the file in which the quantum mechanical orbital data is stored.</span>
        <span class="stringliteral">&quot;orbfile&quot;</span>          : <span class="stringliteral">&quot;&quot;</span>,            <span class="comment"># string</span>
        <span class="comment"># The type of file in which the charge data is stored.</span>
        <span class="stringliteral">&quot;chargefiletype&quot;</span>   : <span class="stringliteral">&quot;xyz&quot;</span>,         <span class="comment"># can be &quot;xyz&quot;, &quot;dx&quot; or &quot;cube&quot;</span>
        <span class="comment"># The path to the file in which the charge data is stored.</span>
        <span class="stringliteral">&quot;chargefile&quot;</span>       : <span class="stringliteral">&quot;&quot;</span>,            <span class="comment"># string</span>
        <span class="comment"># The type of file in which the potential data is stored.</span>
        <span class="stringliteral">&quot;potfiletype&quot;</span>      : <span class="stringliteral">&quot;dx&quot;</span>,          <span class="comment"># can be &quot;dx&quot; or &quot;xyz&quot;</span>
        <span class="comment"># The path to the file in which the potential data is stored.</span>
        <span class="stringliteral">&quot;potfile&quot;</span>          : <span class="stringliteral">&quot;&quot;</span>,            <span class="comment"># string</span>
        <span class="comment"># Whether or not the computed electrostatic potential should be inverted.</span>
        <span class="stringliteral">&quot;invert_potential&quot;</span> : <span class="keyword">False</span>,         <span class="comment"># bool</span>
        <span class="comment"># How external ptoential data shall be interpolation. You can use &quot;nearest&quot; for nearest</span>
        <span class="comment"># neighbour interpolation or &quot;distance&quot; for inverse distance interpolation. The latter uses</span>
        <span class="comment"># the formula weight=1/(R-Norm())^E. See below.</span>
        <span class="stringliteral">&quot;interpolation&quot;</span>    : <span class="stringliteral">&apos;nearest&apos;</span>,     <span class="comment"># can be &quot;distance&quot; or &quot;nearest&quot;</span>
        <span class="comment"># This is &quot;E&quot; in the above formula. Anything below 3 causes far-away values to dominate.</span>
        <span class="stringliteral">&quot;int_exponent&quot;</span>     : 3,             <span class="comment"># int &gt;0</span>
        <span class="comment"># This is &quot;R&quot; in the above formula. The value 2 is the Eukledian norm.</span>
        <span class="stringliteral">&quot;int_root&quot;</span>         : 2,             <span class="comment"># int &gt;0</span>
        <span class="comment"># If the distance between a new and an old point is farther than this, consider its weight</span>
        <span class="comment"># to be zero. When computing the density from orbitals, also use this</span>
        <span class="comment"># cutoff for the distance between an atomic center and the point.</span>
        <span class="stringliteral">&quot;cutoff&quot;</span>       : 7.0,           <span class="comment"># float &gt;0</span>
        <span class="comment"># The total charge of this molecule. Only considered for &quot;potfiletype&quot;==&quot;dx&quot;,</span>
        <span class="comment"># &quot;chargefiletype&quot;==&quot;dx&quot; and &quot;chargefiletype&quot;==&quot;cube&quot;.</span>
        <span class="stringliteral">&quot;total_charge&quot;</span>     : 0,             <span class="comment"># float</span>
        <span class="comment"># The property to compute. Used externally only.</span>
        <span class="stringliteral">&quot;property&quot;</span>         : <span class="stringliteral">&quot;potential&quot;</span>, <span class="comment"># can be &quot;potential&quot; or &quot;density&quot;</span>
        }
</pre></div>
<p>Default config options for obtaining charges and electrostatic potentials. </p>
<p>See comments for explanations of each parameter. </p>

</div>
</div>
<a class="anchor" id="aa9e5c1b1f7b1ec6b678c06a59659bdcb"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::default_vs" ref="aa9e5c1b1f7b1ec6b678c06a59659bdcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#aa9e5c1b1f7b1ec6b678c06a59659bdcb">ManipulateAggregates.aggregate.agg.default_vs</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">{
        <span class="comment"># The type of plot. &quot;vdw&quot; (van-der-Waals surface) and &quot;iso&quot; (isosurface) will show the</span>
        <span class="comment"># elctrostatic potential on these surfaces. The type &quot;simple&quot; shows coloured vdW spheres</span>
        <span class="stringliteral">&quot;type&quot;</span>          : <span class="stringliteral">&quot;simple&quot;</span>, <span class="comment"># &quot;simple&quot;, &quot;vdw&quot; or &quot;iso&quot;</span>
        <span class="comment"># The isovalue for type &quot;iso&quot;. For electron densities, the default is a good value.</span>
        <span class="stringliteral">&quot;isovalue&quot;</span>      : 0.005,    <span class="comment"># float</span>
        <span class="comment"># The type of file from which to get the electron density.</span>
        <span class="stringliteral">&quot;isofiletype&quot;</span>   : <span class="stringliteral">&quot;dx&quot;</span>,     <span class="comment"># only &quot;dx&quot; supported</span>
        <span class="comment"># The path to the file from which to get the electron density.</span>
        <span class="stringliteral">&quot;isofile&quot;</span>       : <span class="stringliteral">&quot;&quot;</span>,       <span class="comment"># string</span>
        <span class="comment"># Criteria for generation of the iso surfaces. For further info, see docstring of funtion</span>
        <span class="comment"># IsosurfacePy in external module FireDeamon for further explanations or the link</span>
        <span class="comment"># http://doc.cgal.org/latest/Surface_mesher/index.html. The default should be fine.</span>
        <span class="stringliteral">&quot;mesh_criteria&quot;</span> : MESH_CRITERIA,    <span class="comment"># list of 3 floats</span>
        <span class="comment"># Precision value used to compute the isosurface. A lower value results in more highly</span>
        <span class="comment"># discretized surfaces.</span>
        <span class="stringliteral">&quot;rel_recision&quot;</span>  : 1.0e-06,  <span class="comment"># float &gt;0</span>
        <span class="comment"># Which atoms shall be used for the generation of the iso surface. Please see the keyword</span>
        <span class="comment"># &quot;atoms&quot; for the method get_iso_surface for more information.</span>
        <span class="stringliteral">&quot;iso_atoms&quot;</span>     : <span class="stringliteral">&quot;auto&quot;</span>,   <span class="comment"># int, list of ints or &quot;all&quot; or &quot;noH&quot; or &quot;auto&quot;</span>
        <span class="comment"># The number of refinement steps for the generation of vdW surfaces. A higher value creates</span>
        <span class="comment"># a more highly discretized surface but needs overproportionally more memory. More than 3</span>
        <span class="comment"># should never be required. See get_vdw_surface.</span>
        <span class="stringliteral">&quot;refine&quot;</span>        : 1,        <span class="comment"># int &gt;0</span>
        <span class="comment"># The shrink factor during surface generation. The default corresponds to vdW surfaces. See</span>
        <span class="comment"># get_vdw_surface for more information.</span>
        <span class="stringliteral">&quot;shrink_factor&quot;</span> : 0.95,     <span class="comment"># float &gt;0 and &lt;1</span>
        <span class="comment"># Scale all vdW radii by this value prior to visualization. Used for visualization types</span>
        <span class="comment"># &quot;simple&quot; and &quot;vdw&quot;.</span>
        <span class="stringliteral">&quot;vdw_scale&quot;</span>     : 1.0,      <span class="comment"># float &gt;0</span>
        <span class="comment"># How the colour scaling shall be obtained. The value &quot;independent&quot; causes positive and</span>
        <span class="comment"># negative colour scales to be independent. The value &quot;dependent&quot; causes the overall maximum</span>
        <span class="comment"># (in terms of the absolute value) to correspond to the highest potential. If a tuple of 2</span>
        <span class="comment"># strings is given, the first is taken as a regular expression and the second one as a</span>
        <span class="comment"># directory. The color scale will be chosen in such a way that the color scales defined in</span>
        <span class="comment"># all the saved visualization state files in the given directory (whose names match the</span>
        <span class="comment"># regular expression) are contained within the new color scale.</span>
        <span class="stringliteral">&quot;colorscale&quot;</span>    : <span class="stringliteral">&quot;independent&quot;</span>,    <span class="comment">#&quot;independent&quot;, &quot;dependent&quot; or &quot;REGEX&quot;,&quot;DIR&quot;</span>
        <span class="comment"># Scale the position of all surface vertices by this value.</span>
        <span class="stringliteral">&quot;zoom&quot;</span>          : 1.0,      <span class="comment"># float &gt;0</span>
        <span class="comment"># The title of the created OpenGL window.</span>
        <span class="stringliteral">&quot;title&quot;</span>         : <span class="stringliteral">&quot;Molecule Visualization&quot;</span>, <span class="comment"># string</span>
        <span class="comment"># The resolution of the OpenGL window in pixels. Also the base resolution of images rendered</span>
        <span class="comment"># by PoVRay.</span>
        <span class="stringliteral">&quot;resolution&quot;</span>    : (1024,768),   <span class="comment"># tuple of 2 ints &gt;0</span>
        <span class="comment"># If True, red, black and blue correspond to a positive, vanishing and negative</span>
        <span class="comment"># electrostatic potential. If False, another color scheme is used (deep blue, light blue,</span>
        <span class="comment"># green, yellow and red) and deep blue/red correspond to a highly positive/negative and</span>
        <span class="comment"># green to a vanishing potential.</span>
        <span class="stringliteral">&quot;high_contrast&quot;</span> : <span class="keyword">True</span>,         <span class="comment"># bool</span>
        <span class="comment"># A trajectory tells the script how to manipulate the visualization of the given aggregate.</span>
        <span class="comment"># All images that are rendered can be saved to disk. The format is comples. Please see the</span>
        <span class="comment"># --render-help message of the &quot;manipagg&quot; executable contained in this bundle.</span>
        <span class="stringliteral">&quot;renderpath&quot;</span>    : <span class="keywordtype">None</span>,         <span class="comment"># string</span>
        <span class="comment"># Whether or not the OpenGL window shall be shown. Only makes sense with a renderpath.</span>
        <span class="stringliteral">&quot;hide&quot;</span>          : <span class="keyword">False</span>,        <span class="comment"># bool</span>
        <span class="comment"># If &lt;=0, PoVRay support is switched off. If &gt;0, the resolution of the OpenGL plot will be</span>
        <span class="comment"># scaled by this value to get the resolution for the corresponding PoVRay image.</span>
        <span class="stringliteral">&quot;povray&quot;</span>        : 1,            <span class="comment"># int &gt;0</span>
        <span class="comment"># A file name (no path!!!) to which the visualization state can be saved. No default.</span>
        <span class="comment"># Information about when and why this state was saved might be prefixed to the name. Saving</span>
        <span class="comment"># the visualization state only works with types &quot;vdw&quot; and &quot;iso&quot;.</span>
        <span class="stringliteral">&quot;savefile&quot;</span>      : <span class="keywordtype">None</span>,         <span class="comment"># string</span>
        <span class="comment"># Whether or not to save the visualization state at the beginning of the visualization.</span>
        <span class="stringliteral">&quot;savestart&quot;</span>     : <span class="keyword">False</span>,        <span class="comment"># bool</span>
        <span class="comment"># Whether or not to save the visualization state at the end of the visualization.</span>
        <span class="stringliteral">&quot;saveend&quot;</span>       : <span class="keyword">False</span>,        <span class="comment"># bool</span>
        <span class="comment"># Wether or not to align the aggregate prior to visualization. This is recommened to make</span>
        <span class="comment"># the aggregate better visible. The actual object will not be changed, only the</span>
        <span class="comment"># visualization will be adjusted.</span>
        <span class="stringliteral">&quot;align&quot;</span>         : <span class="keyword">True</span>,         <span class="comment"># bool</span>
        <span class="comment"># The non-mass-weighted center of the aggregate will be pot here.</span>
        <span class="stringliteral">&quot;align_center&quot;</span>  : [0.0,0.0,0.0],<span class="comment"># list of 3 floats</span>
        <span class="comment"># The third main axis (usually the longest extend) of the aggregate will point in this</span>
        <span class="comment"># direction.</span>
        <span class="stringliteral">&quot;align_main3&quot;</span>   : [1.0,0.0,0.0],<span class="comment"># list of 3 floats</span>
        <span class="comment"># The second main axis of the aggregate will point in this direction.</span>
        <span class="stringliteral">&quot;align_main2&quot;</span>   : [0.0,1.0,0.0],<span class="comment"># list of 3 floats</span>
        }
</pre></div>
<p>Default config options for surface generation and visualization. </p>
<p>See comments for explanations of each parameter. </p>

</div>
</div>
<a class="anchor" id="a60e64905fe9b3a196cea35fd85a70c56"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::ff" ref="a60e64905fe9b3a196cea35fd85a70c56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a60e64905fe9b3a196cea35fd85a70c56">ManipulateAggregates::aggregate.agg::ff</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(OBForceField) the underlying OpenBabel force field data structure </p>

</div>
</div>
<a class="anchor" id="a4988c22a78c3fd03d96ca39e8ffe526a"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::info" ref="a4988c22a78c3fd03d96ca39e8ffe526a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a4988c22a78c3fd03d96ca39e8ffe526a">ManipulateAggregates::aggregate.agg::info</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(dictionary) contains information about the file this object was created from </p>

</div>
</div>
<a class="anchor" id="a1a3588681f2a0ec56786d87a7b2c17e2"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::obmol" ref="a1a3588681f2a0ec56786d87a7b2c17e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#a1a3588681f2a0ec56786d87a7b2c17e2">ManipulateAggregates::aggregate.agg::obmol</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(of type OBAggregate) the underlying OpenBabel data structure </p>

</div>
</div>
<a class="anchor" id="acec8fc3f0c0c08cb85bfa6235b5740e6"></a><!-- doxytag: member="ManipulateAggregates::aggregate::agg::vs" ref="acec8fc3f0c0c08cb85bfa6235b5740e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html#acec8fc3f0c0c08cb85bfa6235b5740e6">ManipulateAggregates::aggregate.agg::vs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(dictionary) contains information about desired visualizations and surface generation </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>aggregate/__init__.py</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Nov 2016 for ManipulateAggregates by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
