<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ManipulateAggregates: Package ManipulateAggregates.aggregate.hlb</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&nbsp;Functions</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceManipulateAggregates.html">ManipulateAggregates</a>.<a class="el" href="namespaceManipulateAggregates_1_1aggregate.html">aggregate</a>.<a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html">hlb</a>
  </div>
</div>
<div class="contents">
<h1>Package ManipulateAggregates.aggregate.hlb</h1>
<p>Calculate the HLB-value using multiple methods.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a63f9fcfb4e9957819ba31b90ca5365b8">part_molecule</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Part a molecule by a plane (in Hessian normal form).  <a href="#a63f9fcfb4e9957819ba31b90ca5365b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a1af713df7fa3849c436dd423431e9877">list_min</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the minimum element of a list.  <a href="#a1af713df7fa3849c436dd423431e9877"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a5b32403147f9013bc6e710595dade9b0">pseudo_energy_simple</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the simple method to determine the optimal location of the air-water interface.  <a href="#a5b32403147f9013bc6e710595dade9b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a319d0eba1f2a1e2e34551ed79be2ea9c">pseudo_energy_complex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the complex method to determine the optimal location of the air-water interface.  <a href="#a319d0eba1f2a1e2e34551ed79be2ea9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#aac2cf87b6c7296c13f2a8dfd01659cb8">get_HLB_simple</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the HLB value according to the simple method.  <a href="#aac2cf87b6c7296c13f2a8dfd01659cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a808c06e6c22d9587448e4169b8bc23f5">get_HLB_complex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the HLB value according to the complex method.  <a href="#a808c06e6c22d9587448e4169b8bc23f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#ac995d8b5c73be202dda860369cce39d0">compute</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper function for the computation of the HLB value.  <a href="#ac995d8b5c73be202dda860369cce39d0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#ad9b7682de426b12a03615573d99a8373">MASSES_DICT</a> = {&quot;H&quot;:1.0008, &quot;O&quot;:16.0, &quot;S&quot;:32.06, &quot;N&quot;:14.01, &quot;F&quot;:19.0, &quot;Cl&quot;:35.45, &quot;C&quot;:12.01, &quot;Ni&quot;:58.69}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this dictionary stores all masses of the atoms to be used in relative units  <a href="#ad9b7682de426b12a03615573d99a8373"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#ab169c84941393a0c597fbe9555487a40">WEIGHTS_DICT</a> = {&quot;H&quot;:0, &quot;O&quot;:1, &quot;S&quot;:1, &quot;N&quot;:1, &quot;F&quot;:1, &quot;Cl&quot;:1, &quot;C&quot;:-0.4, &quot;Ni&quot;:1}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this dictionary stores all weights to judge which atom is rather hydrophilic (high positive value) and which is not  <a href="#ab169c84941393a0c597fbe9555487a40"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Calculate the HLB-value using multiple methods. </p>
<p>There are two methods supported by this subsubmodule:</p>
<ol type="1">
<li>simple: Scan the molecule with a plane that is allowed to cut midway through bonds with a maximum angle of 30° to the bond. Assign positive values to all hetero atoms and negative values to C and H. Try to maximize the number of heteroatoms on one side and the number of C and H on the other side.</li>
<li>complex: Scan the molecule with a plane that is allowed to cut midway through bonds with a maximum angle of 30° to the bond. Try to maximize the amount of positive electrostatic potential on one side and try to minimze the amount of negative electrostatic potential on the other side of the plane.</li>
</ol>
<p>I highly recommend using the simple method as gave values closer to measured ones, up to now. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac995d8b5c73be202dda860369cce39d0"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::compute" ref="ac995d8b5c73be202dda860369cce39d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.compute </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>phi_step_degree</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>theta_step_degree</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>theta_range_degree</em> = <code>10.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>no_hydrogen</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>&quot;simple&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>write</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_refinements</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>dependence</em> = <code>'independent'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper function for the computation of the HLB value. </p>
<p>If desired, the lipophilic and hydrophilic parts can be written to files.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mol</em>&nbsp;</td><td>(object of class <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">ManipulateAggregates.aggregate.agg</a>) the molecule whose HLB value shall be computed</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_step_degree</em>&nbsp;</td><td>(float) stepsize (in degrees) for phi angle for the plane around the bond vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>theta_step_degree</em>&nbsp;</td><td>(float) tepsize (in degrees) for theta angle for the plane around the bond vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>theta_range_degree</em>&nbsp;</td><td>(float) theta will vary from the negative of this value to the positive of this value around the bond vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_hydrogen</em>&nbsp;</td><td>(bool) whether or not to irgnore bonds to hydrogens as cutable bonds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>(string) "simple" or "complex" depending on which method is desired. See <a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html" title="Calculate the HLB-value using multiple methods.">ManipulateAggregates.aggregate.hlb</a> for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write</em>&nbsp;</td><td>(bool) whether or not to write the lipophilic and hydrophilic parts to files (prefixed appropriately) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nr_refinements</em>&nbsp;</td><td>(int) how many refinement steps to use during skin surface generation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dependence</em>&nbsp;</td><td>(string) either "dependent" (scale the potential values so that the highest overall [with respect to absolute value] shall be set to 1) or "independent" (normalize positive and negative potentials independently). Only works if method is "complex".</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of hlb_value, normal_vector and point_in_plane. Here, hlb_value (float) is the determined HLB value, normal_vector (list of 3 floats) is the normal vector of the plane that optimally parts the molecule into lipophilic and hydrophilic parts and point_in_plane (list of 3 floats) is the point in the plane (required for Hessian normal form) </dd></dl>

</div>
</div>
<a class="anchor" id="a808c06e6c22d9587448e4169b8bc23f5"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::get_HLB_complex" ref="a808c06e6c22d9587448e4169b8bc23f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.get_HLB_complex </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>thetas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>phis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>no_hydrogen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_refinements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>dependence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>relative_angles</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the HLB value according to the complex method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mol</em>&nbsp;</td><td>(object of class <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">ManipulateAggregates.aggregate.agg</a>) the molecule whose HLB value shall be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thetas</em>&nbsp;</td><td>(list of floats) same as <em>phis</em> but for the theta angle of spherical coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phis</em>&nbsp;</td><td>(list of floats) contains all the angles in the x-y-plane the plane should screen if <em>relative_angles</em> is True, this will correspond to the new x-y-plane after the rotation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_hydrogen</em>&nbsp;</td><td>(bool) whether or not to irgnore bonds to hydrogens as cutable bonds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nr_refinements</em>&nbsp;</td><td>(int) how many refinement steps to use during skin surface generation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dependence</em>&nbsp;</td><td>(string) either "dependent" (scale the potential values so that the highest overall [with respect to absolute value] shall be set to 1) or "independent" (normalize positive and negative potentials independently)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phis</em>&nbsp;</td><td>(list of floats) contains all the angles in the x-y-plane the plane should screen if <em>relative_angles</em> is True, this will correspond to the new x-y-plane after the rotation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thetas</em>&nbsp;</td><td>(list of floats) same as <em>phis</em> but for the theta angle of spherical coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relative_angles</em>&nbsp;</td><td>(bool) if True, realign the z-axis to the bond vector prior to scanning</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of hlb_value, normal_vector and point_in_plane. Here, hlb_value (float) is the determined HLB value, normal_vector (list of 3 floats) is the normal vector of the plane that optimally parts the molecule into lipophilic and hydrophilic parts and point_in_plane (list of 3 floats) is the point in the plane (required for Hessian normal form) </dd></dl>

</div>
</div>
<a class="anchor" id="aac2cf87b6c7296c13f2a8dfd01659cb8"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::get_HLB_simple" ref="aac2cf87b6c7296c13f2a8dfd01659cb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.get_HLB_simple </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>thetas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>phis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>no_hydrogen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>relative_angles</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>pseudo_energy_func</em> = <code>pseudo_energy_simple</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the HLB value according to the simple method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mol</em>&nbsp;</td><td>(object of class <a class="el" href="classManipulateAggregates_1_1aggregate_1_1agg.html" title="The agg class (agg stands for aggregate).">ManipulateAggregates.aggregate.agg</a>) the molecule whose HLB value shall be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thetas</em>&nbsp;</td><td>(list of floats) same as <em>phis</em> but for the theta angle of spherical coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phis</em>&nbsp;</td><td>(list of floats) contains all the angles in the x-y-plane the plane should screen if <em>relative_angles</em> is True, this will correspond to the new x-y-plane after the rotation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_hydrogen</em>&nbsp;</td><td>(bool) whether or not to irgnore bonds to hydrogens as cutable bonds</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relative_angles</em>&nbsp;</td><td>(bool) if True, realign the z-axis to the bond vector prior to scanning </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pseudo_energy_func</em>&nbsp;</td><td>(function like <a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#a5b32403147f9013bc6e710595dade9b0" title="Use the simple method to determine the optimal location of the air-water interface...">ManipulateAggregates.aggregate.hlb.pseudo_energy_simple</a>) returns the pseudo energy associated with each parting plane</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tuple of hlb_value, normal_vector and point_in_plane. Here, hlb_value (float) is the determined HLB value, normal_vector (list of 3 floats) is the normal vector of the plane that optimally parts the molecule into lipophilic and hydrophilic parts and point_in_plane (list of 3 floats) is the point in the plane (required for Hessian normal form) </dd></dl>

</div>
</div>
<a class="anchor" id="a1af713df7fa3849c436dd423431e9877"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::list_min" ref="a1af713df7fa3849c436dd423431e9877" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.list_min </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>key</em> = <code>lambda&nbsp;x:x</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimum element of a list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum element of a list</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>(list) list whose minimum element shall be determined</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>(function of 1 argument) this function is applied to every element of <em>l</em> to get an element that the "min" function understands </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63f9fcfb4e9957819ba31b90ca5365b8"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::part_molecule" ref="a63f9fcfb4e9957819ba31b90ca5365b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.part_molecule </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Part a molecule by a plane (in Hessian normal form). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of indices of all elements of <em>structure</em> that are on the side of the plane (defined by <em>normal_vector</em> and <em>coordinate</em>) to which the normal vector points</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>structure</em>&nbsp;</td><td>(list of vectors) Cartesian coordinates that shall be separated by the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal_vector</em>&nbsp;</td><td>(list of 3 floats) normal vector for Hessian normal form </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>(list of 3 floats) point in the plane for Hessian normal form </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a319d0eba1f2a1e2e34551ed79be2ea9c"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::pseudo_energy_complex" ref="a319d0eba1f2a1e2e34551ed79be2ea9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.pseudo_energy_complex </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>max_potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>weights</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the complex method to determine the optimal location of the air-water interface. </p>
<p>Estimate the energy the system would have if separated by a plane on whose left (IN the direction of the normal vector) there is an unpolar solvend and on whose right there is a polar solvent, like H2O. That means, aggregating potential unequal 0 on the right side is good whereas aggregating potential close to 0 is good on the left.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_potential</em>&nbsp;</td><td>(float) the maximum value of <em>potential</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>(numpy array of 3 floats) an arbitrary point on the plane that separates the system </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vector</em>&nbsp;</td><td>(numpy array of 3 floats) the normal vector of the plane that separates the system. This need not be normalized but MUST HAVE A NON-VANISHING NORM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>centers</em>&nbsp;</td><td>(numpy array of shape 1,3 and dtype float) Cartesian coordinates where the potentials are located. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>potential</em>&nbsp;</td><td>(numpy array of shape 1, and dtype float) contains the potential values (all positive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>(numpy array of shape 1, and dtype float) if some potentials shall count more than others, for instance one bit should in every case be on a specific side, then declare something other all ones for this. Here, since each potential is in the center of a triangle, this is the area of the triangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b32403147f9013bc6e710595dade9b0"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::pseudo_energy_simple" ref="a5b32403147f9013bc6e710595dade9b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ManipulateAggregates.aggregate.hlb.pseudo_energy_simple </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>point_in_plane</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the simple method to determine the optimal location of the air-water interface. </p>
<p>With the given structure, calculate the "energy" associated with it if the plane, given in its Hessian normal form, cuts through the molecule. The value is high and positive, if atoms with a positive weight are on the side where the normal vector points and atoms with negative weights are on the opposite side of the plane.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pseudo energy associated with the current system (i.e., the plane defined by <em>normal_vector</em> and <em>point_in_plane</em> cutting the molecule defined by <em>structure</em> and <em>names</em>)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>structure</em>&nbsp;</td><td>(a list of 3-element vectors) the cartesian coordinates of all the atoms in the structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>(list of strings) element names of all the atoms in the structure (used to determine whether they are hetero atoms or not) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal_vector</em>&nbsp;</td><td>(list of 3 floats) the normal vector of the plane in its Hessian normal form </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point_in_plane</em>&nbsp;</td><td>(list of 3 floats) the Cartesian coordinates of the point that lies in the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ad9b7682de426b12a03615573d99a8373"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::MASSES_DICT" ref="ad9b7682de426b12a03615573d99a8373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#ad9b7682de426b12a03615573d99a8373">ManipulateAggregates::aggregate::hlb.MASSES_DICT</a> = {&quot;H&quot;:1.0008, &quot;O&quot;:16.0, &quot;S&quot;:32.06, &quot;N&quot;:14.01, &quot;F&quot;:19.0, &quot;Cl&quot;:35.45, &quot;C&quot;:12.01, &quot;Ni&quot;:58.69}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this dictionary stores all masses of the atoms to be used in relative units </p>

</div>
</div>
<a class="anchor" id="ab169c84941393a0c597fbe9555487a40"></a><!-- doxytag: member="ManipulateAggregates::aggregate::hlb::WEIGHTS_DICT" ref="ab169c84941393a0c597fbe9555487a40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="namespaceManipulateAggregates_1_1aggregate_1_1hlb.html#ab169c84941393a0c597fbe9555487a40">ManipulateAggregates::aggregate::hlb.WEIGHTS_DICT</a> = {&quot;H&quot;:0, &quot;O&quot;:1, &quot;S&quot;:1, &quot;N&quot;:1, &quot;F&quot;:1, &quot;Cl&quot;:1, &quot;C&quot;:-0.4, &quot;Ni&quot;:1}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this dictionary stores all weights to judge which atom is rather hydrophilic (high positive value) and which is not </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Nov 2016 for ManipulateAggregates by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
